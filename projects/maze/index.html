<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üåÄ MAZE GENERATOR ¬∑ solver visualizer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(145deg, #1b2a30, #0e1d24);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Inter', 'Segoe UI', monospace;
      padding: 1.5rem;
    }

    .maze-card {
      max-width: 1300px;
      width: 100%;
      background: rgba(25, 45, 50, 0.9);
      backdrop-filter: blur(8px);
      border: 3px solid #ba9f6a;
      border-radius: 3.5rem;
      padding: 2rem 2.5rem;
      box-shadow: 0 35px 50px -15px black;
    }

    h1 {
      font-size: 3rem;
      font-weight: 700;
      color: #fade9b;
      text-shadow: 4px 4px 0 #4d3d1f;
      display: flex;
      align-items: center;
      gap: 2rem;
      margin-bottom: 1rem;
    }
    h1 span {
      font-size: 1.6rem;
      background: #325a5a;
      padding: 0.3rem 2.2rem;
      border-radius: 60px;
      border: 2px solid #edc87b;
      color: #ffecb3;
    }

    .workspace {
      display: grid;
      grid-template-columns: 1.3fr 1fr;
      gap: 2rem;
      margin-top: 1rem;
    }

    /* left: canvas */
    .canvas-area {
      background: #1e3b40;
      border-radius: 2.5rem;
      padding: 1.5rem;
      border: 3px solid #c8a35c;
    }

    #mazeCanvas {
      display: block;
      margin: 0 auto;
      background: #1e352a;
      border-radius: 2rem;
      box-shadow: 0 15px 25px -8px black;
      width: 100%;
      height: auto;
      image-rendering: pixelated;
      border: 2px solid #b9995b;
    }

    /* right: controls */
    .control-panel {
      background: #1a3f44;
      border-radius: 2.5rem;
      padding: 1.8rem;
      border: 2px solid #caa45c;
      box-shadow: inset 0 0 0 2px #47655e;
    }

    .control-group {
      margin-bottom: 2rem;
    }
    .control-group h3 {
      color: #fcdb9f;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 2px;
      border-bottom: 2px dashed #b39055;
      padding-bottom: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .slider-item {
      margin-bottom: 1.5rem;
    }
    .slider-item label {
      display: flex;
      justify-content: space-between;
      color: #eedbbd;
      font-size: 1rem;
      margin-bottom: 0.4rem;
    }
    .slider-item input[type=range] {
      width: 100%;
      height: 10px;
      background: #2d605c;
      border-radius: 20px;
      -webkit-appearance: none;
    }
    .slider-item input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 24px;
      height: 24px;
      background: #f5bc6c;
      border-radius: 50%;
      border: 2px solid white;
      cursor: pointer;
    }
    .value-badge {
      background: #2f605a;
      padding: 0.2rem 1.2rem;
      border-radius: 40px;
      color: #fad89d;
    }

    .btn-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin: 1.5rem 0;
    }
    .btn {
      background: #e8b56e;
      border: none;
      border-radius: 50px;
      padding: 1rem 0.5rem;
      font-weight: 700;
      font-size: 1.2rem;
      color: #1f3a2c;
      cursor: pointer;
      border-bottom: 5px solid #9e7b48;
      transition: 0.07s;
    }
    .btn:active { transform: translateY(4px); border-bottom-width: 2px; }
    .btn-secondary {
      background: #4f7670;
      border-bottom-color: #2d524a;
      color: #ffefcf;
    }
    .btn:disabled {
      opacity: 0.4;
      pointer-events: none;
    }

    .algorithm-selector {
      display: flex;
      gap: 1rem;
      margin: 1.2rem 0;
    }
    .algo-btn {
      flex: 1;
      background: #2b5b5b;
      border: 2px solid #cfa35b;
      color: #f7d9a0;
      padding: 0.8rem;
      border-radius: 40px;
      font-weight: 600;
      cursor: pointer;
    }
    .algo-btn.active {
      background: #c99a54;
      color: #1e3520;
      border-color: #f5e2b6;
    }

    .stats-panel {
      background: #0f3737;
      border-radius: 2rem;
      padding: 1.2rem;
      margin-top: 1.5rem;
      color: #f2dbb2;
      display: flex;
      justify-content: space-between;
      border: 1px solid #b28f52;
    }

    .legend {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      margin-top: 1rem;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: #eadbba;
    }
    .color-box {
      width: 24px;
      height: 24px;
      border-radius: 8px;
    }
    .color-box.start { background: #44cf6c; }
    .color-box.end { background: #f5544e; }
    .color-box.path { background: #ffe066; }
    .color-box.solution { background: #f5a97f; }
  </style>
</head>
<body>
  <div class="maze-card">
    <h1>
      üåÄ MAZE GENERATOR & SOLVER
      <span>DFS ¬∑ BFS ¬∑ A*</span>
    </h1>

    <div class="workspace">
      <!-- left: canvas -->
      <div class="canvas-area">
        <canvas id="mazeCanvas" width="600" height="400"></canvas>
      </div>

      <!-- right: controls -->
      <div class="control-panel">
        <div class="control-group">
          <h3>üìê DIMENSIONS</h3>
          <div class="slider-item">
            <label>rows <span id="rowsVal" class="value-badge">20</span></label>
            <input type="range" id="rowsSlider" min="8" max="40" value="20" step="1">
          </div>
          <div class="slider-item">
            <label>cols <span id="colsVal" class="value-badge">30</span></label>
            <input type="range" id="colsSlider" min="8" max="50" value="30" step="1">
          </div>
        </div>

        <div class="control-group">
          <h3>üéÆ GENERATE</h3>
          <div class="btn-grid">
            <button class="btn" id="generateDFS">üå≤ DFS maze</button>
            <button class="btn" id="generatePrim">üî∑ Prim maze</button>
          </div>
          <div class="btn-grid">
            <button class="btn btn-secondary" id="clearWalls">‚óªÔ∏è clear walls</button>
            <button class="btn btn-secondary" id="addRandomWalls">üå´Ô∏è random walls</button>
          </div>
        </div>

        <div class="control-group">
          <h3>üîç SOLVE</h3>
          <div class="algorithm-selector" id="algoSelector">
            <button class="algo-btn active" data-algo="dfs">DFS</button>
            <button class="algo-btn" data-algo="bfs">BFS</button>
            <button class="algo-btn" data-algo="astar">A*</button>
          </div>
          <div class="btn-grid">
            <button class="btn" id="solveBtn">üöÄ FIND PATH</button>
            <button class="btn btn-secondary" id="resetSolution">‚Ü∫ reset path</button>
          </div>
        </div>

        <div class="stats-panel">
          <span>üìè size: <span id="sizeInfo">20x30</span></span>
          <span>‚ö° steps: <span id="stepCount">0</span></span>
          <span>üéØ length: <span id="pathLength">0</span></span>
        </div>

        <div class="legend">
          <div class="legend-item"><span class="color-box start"></span> start</div>
          <div class="legend-item"><span class="color-box end"></span> end</div>
          <div class="legend-item"><span class="color-box path"></span> visited</div>
          <div class="legend-item"><span class="color-box solution"></span> solution</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (function() {
      const canvas = document.getElementById('mazeCanvas');
      const ctx = canvas.getContext('2d');
      
      // dimensions
      let rows = 20, cols = 30;
      let cellSize = Math.min(Math.floor(canvas.width / cols), Math.floor(canvas.height / rows));
      
      // maze grid: 0 = path, 1 = wall
      let grid = [];
      
      // start and end positions
      let start = { row: 1, col: 1 };
      let end = { row: rows-2, col: cols-2 };
      
      // visited and solution for display
      let visited = [];
      let solution = [];
      let solving = false;
      
      // UI elements
      const rowsSlider = document.getElementById('rowsSlider');
      const colsSlider = document.getElementById('colsSlider');
      const rowsVal = document.getElementById('rowsVal');
      const colsVal = document.getElementById('colsVal');
      const sizeInfo = document.getElementById('sizeInfo');
      const stepCount = document.getElementById('stepCount');
      const pathLength = document.getElementById('pathLength');
      
      const generateDFS = document.getElementById('generateDFS');
      const generatePrim = document.getElementById('generatePrim');
      const clearWalls = document.getElementById('clearWalls');
      const addRandomWalls = document.getElementById('addRandomWalls');
      const solveBtn = document.getElementById('solveBtn');
      const resetSolution = document.getElementById('resetSolution');
      
      const algoBtns = document.querySelectorAll('.algo-btn');
      let currentAlgo = 'dfs';
      
      // initialize grid
      function initGrid(rows, cols, fill = 1) {
        grid = Array(rows).fill().map(() => Array(cols).fill(fill));
        // ensure start and end are within bounds
        start.row = Math.min(start.row, rows-2);
        start.col = Math.min(start.col, cols-2);
        end.row = Math.min(end.row, rows-2);
        end.col = Math.min(end.col, cols-2);
        
        // set start and end as paths
        if (start.row >= 0 && start.col >= 0) grid[start.row][start.col] = 0;
        if (end.row >= 0 && end.col >= 0) grid[end.row][end.col] = 0;
        
        visited = [];
        solution = [];
        updateSizeInfo();
        drawMaze();
      }
      
      // update size info
      function updateSizeInfo() {
        rowsVal.innerText = rows;
        colsVal.innerText = cols;
        sizeInfo.innerText = `${rows}x${cols}`;
        cellSize = Math.min(Math.floor(canvas.width / cols), Math.floor(canvas.height / rows));
      }
      
      // draw maze
      function drawMaze() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // draw cells
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            let x = c * cellSize;
            let y = r * cellSize;
            
            // cell color based on type
            if (grid[r][c] === 1) {
              ctx.fillStyle = '#2d4a4a'; // wall
            } else {
              ctx.fillStyle = '#95b8ae'; // path
            }
            
            ctx.fillRect(x, y, cellSize-1, cellSize-1);
            
            // draw visited
            if (visited.length > 0 && visited.some(v => v.row === r && v.col === c)) {
              ctx.fillStyle = '#ffe06690';
              ctx.fillRect(x, y, cellSize-1, cellSize-1);
            }
            
            // draw solution
            if (solution.length > 0 && solution.some(s => s.row === r && s.col === c)) {
              ctx.fillStyle = '#f5a97f90';
              ctx.fillRect(x, y, cellSize-1, cellSize-1);
            }
          }
        }
        
        // draw start and end
        ctx.fillStyle = '#44cf6c';
        ctx.fillRect(start.col * cellSize, start.row * cellSize, cellSize-1, cellSize-1);
        
        ctx.fillStyle = '#f5544e';
        ctx.fillRect(end.col * cellSize, end.row * cellSize, cellSize-1, cellSize-1);
        
        // grid lines
        ctx.strokeStyle = '#5f7e7a';
        ctx.lineWidth = 1;
        for (let r = 0; r <= rows; r++) {
          ctx.beginPath();
          ctx.moveTo(0, r * cellSize);
          ctx.lineTo(canvas.width, r * cellSize);
          ctx.strokeStyle = '#3d5f5b';
          ctx.stroke();
        }
        for (let c = 0; c <= cols; c++) {
          ctx.beginPath();
          ctx.moveTo(c * cellSize, 0);
          ctx.lineTo(c * cellSize, canvas.height);
          ctx.stroke();
        }
      }
      
      // ----- MAZE GENERATION ALGORITHMS -----
      
      // DFS recursive backtracking maze
      function generateDFSMaze() {
        // initialize all walls
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            grid[r][c] = 1;
          }
        }
        
        // start from (1,1)
        let stack = [{ row: 1, col: 1 }];
        grid[1][1] = 0;
        
        const dirs = [
          [0, 2], [2, 0], [0, -2], [-2, 0]
        ];
        
        while (stack.length > 0) {
          let current = stack[stack.length-1];
          let { row, col } = current;
          
          // get unvisited neighbors (2 steps away)
          let neighbors = [];
          for (let [dr, dc] of dirs) {
            let nr = row + dr;
            let nc = col + dc;
            if (nr > 0 && nr < rows-1 && nc > 0 && nc < cols-1 && grid[nr][nc] === 1) {
              neighbors.push({ row: nr, col: nc, midRow: row + dr/2, midCol: col + dc/2 });
            }
          }
          
          if (neighbors.length > 0) {
            // choose random neighbor
            let next = neighbors[Math.floor(Math.random() * neighbors.length)];
            // carve path
            grid[next.midRow][next.midCol] = 0;
            grid[next.row][next.col] = 0;
            stack.push(next);
          } else {
            stack.pop();
          }
        }
        
        // ensure start and end are open
        grid[start.row][start.col] = 0;
        grid[end.row][end.col] = 0;
        
        visited = [];
        solution = [];
        drawMaze();
      }
      
      // Prim's algorithm maze
      function generatePrimMaze() {
        // initialize all walls
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            grid[r][c] = 1;
          }
        }
        
        // start with a random cell
        let startRow = 1;
        let startCol = 1;
        grid[startRow][startCol] = 0;
        
        let frontier = [];
        // add frontier cells (2 steps away)
        const dirs = [[0,2], [2,0], [0,-2], [-2,0]];
        for (let [dr, dc] of dirs) {
          let nr = startRow + dr;
          let nc = startCol + dc;
          if (nr > 0 && nr < rows-1 && nc > 0 && nc < cols-1 && grid[nr][nc] === 1) {
            frontier.push({ row: nr, col: nc, fromRow: startRow, fromCol: startCol });
          }
        }
        
        while (frontier.length > 0) {
          // pick random frontier
          let idx = Math.floor(Math.random() * frontier.length);
          let cell = frontier[idx];
          frontier.splice(idx, 1);
          
          if (grid[cell.row][cell.col] === 1) {
            // carve path from cell to a random adjacent path
            let neighbors = [];
            for (let [dr, dc] of dirs) {
              let nr = cell.row + dr;
              let nc = cell.col + dc;
              if (nr > 0 && nr < rows-1 && nc > 0 && nc < cols-1 && grid[nr][nc] === 0) {
                neighbors.push({ row: nr, col: nc, midRow: cell.row + dr/2, midCol: cell.col + dc/2 });
              }
            }
            
            if (neighbors.length > 0) {
              let connect = neighbors[Math.floor(Math.random() * neighbors.length)];
              grid[connect.midRow][connect.midCol] = 0;
              grid[cell.row][cell.col] = 0;
              
              // add new frontiers
              for (let [dr, dc] of dirs) {
                let nr = cell.row + dr;
                let nc = cell.col + dc;
                if (nr > 0 && nr < rows-1 && nc > 0 && nc < cols-1 && grid[nr][nc] === 1) {
                  frontier.push({ row: nr, col: nc, fromRow: cell.row, fromCol: cell.col });
                }
              }
            }
          }
        }
        
        grid[start.row][start.col] = 0;
        grid[end.row][end.col] = 0;
        
        visited = [];
        solution = [];
        drawMaze();
      }
      
      // random walls (density ~30%)
      function addRandomWallsFn() {
        for (let r = 1; r < rows-1; r++) {
          for (let c = 1; c < cols-1; c++) {
            if (Math.random() < 0.3 && !(r === start.row && c === start.col) && !(r === end.row && c === end.col)) {
              grid[r][c] = 1;
            } else {
              if (grid[r][c] !== 0) grid[r][c] = 0;
            }
          }
        }
        visited = [];
        solution = [];
        drawMaze();
      }
      
      // ----- SOLVING ALGORITHMS -----
      
      // DFS solver (recursive)
      function solveDFS() {
        visited = [];
        solution = [];
        
        let stack = [{ row: start.row, col: start.col, path: [{ row: start.row, col: start.col }] }];
        let visitedSet = new Set();
        visitedSet.add(`${start.row},${start.col}`);
        
        while (stack.length > 0) {
          let { row, col, path } = stack.pop();
          
          if (row === end.row && col === end.col) {
            solution = path;
            stepCount.innerText = visited.length;
            pathLength.innerText = path.length;
            drawMaze();
            return true;
          }
          
          visited.push({ row, col });
          
          // check neighbors
          const dirs = [[0,1], [1,0], [0,-1], [-1,0]];
          for (let [dr, dc] of dirs) {
            let nr = row + dr;
            let nc = col + dc;
            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] === 0 && !visitedSet.has(`${nr},${nc}`)) {
              visitedSet.add(`${nr},${nc}`);
              stack.push({ row: nr, col: nc, path: [...path, { row: nr, col: nc }] });
            }
          }
        }
        
        stepCount.innerText = visited.length;
        pathLength.innerText = 0;
        drawMaze();
        return false;
      }
      
      // BFS solver
      function solveBFS() {
        visited = [];
        solution = [];
        
        let queue = [{ row: start.row, col: start.col, path: [{ row: start.row, col: start.col }] }];
        let visitedSet = new Set();
        visitedSet.add(`${start.row},${start.col}`);
        
        while (queue.length > 0) {
          let { row, col, path } = queue.shift();
          
          if (row === end.row && col === end.col) {
            solution = path;
            stepCount.innerText = visited.length;
            pathLength.innerText = path.length;
            drawMaze();
            return true;
          }
          
          visited.push({ row, col });
          
          const dirs = [[0,1], [1,0], [0,-1], [-1,0]];
          for (let [dr, dc] of dirs) {
            let nr = row + dr;
            let nc = col + dc;
            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] === 0 && !visitedSet.has(`${nr},${nc}`)) {
              visitedSet.add(`${nr},${nc}`);
              queue.push({ row: nr, col: nc, path: [...path, { row: nr, col: nc }] });
            }
          }
        }
        
        stepCount.innerText = visited.length;
        pathLength.innerText = 0;
        drawMaze();
        return false;
      }
      
      // A* solver (manhattan distance)
      function solveAStar() {
        visited = [];
        solution = [];
        
        function heuristic(r, c) {
          return Math.abs(r - end.row) + Math.abs(c - end.col);
        }
        
        let openSet = [{ row: start.row, col: start.col, g: 0, f: heuristic(start.row, start.col), path: [{ row: start.row, col: start.col }] }];
        let closedSet = new Set();
        
        while (openSet.length > 0) {
          // find node with smallest f
          let idx = 0;
          for (let i = 1; i < openSet.length; i++) {
            if (openSet[i].f < openSet[idx].f) idx = i;
          }
          let current = openSet[idx];
          openSet.splice(idx, 1);
          
          if (current.row === end.row && current.col === end.col) {
            solution = current.path;
            stepCount.innerText = visited.length;
            pathLength.innerText = current.path.length;
            drawMaze();
            return true;
          }
          
          closedSet.add(`${current.row},${current.col}`);
          visited.push({ row: current.row, col: current.col });
          
          const dirs = [[0,1], [1,0], [0,-1], [-1,0]];
          for (let [dr, dc] of dirs) {
            let nr = current.row + dr;
            let nc = current.col + dc;
            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] === 0 && !closedSet.has(`${nr},${nc}`)) {
              let g = current.g + 1;
              let h = heuristic(nr, nc);
              let f = g + h;
              
              // check if in open set with better g
              let inOpen = openSet.find(n => n.row === nr && n.col === nc);
              if (!inOpen || g < inOpen.g) {
                if (!inOpen) {
                  openSet.push({ row: nr, col: nc, g: g, f: f, path: [...current.path, { row: nr, col: nc }] });
                } else {
                  inOpen.g = g;
                  inOpen.f = f;
                  inOpen.path = [...current.path, { row: nr, col: nc }];
                }
              }
            }
          }
        }
        
        stepCount.innerText = visited.length;
        pathLength.innerText = 0;
        drawMaze();
        return false;
      }
      
      // reset solution display
      function resetSolutionFn() {
        visited = [];
        solution = [];
        stepCount.innerText = 0;
        pathLength.innerText = 0;
        drawMaze();
      }
      
      // clear all walls (only keep border)
      function clearWallsFn() {
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            if (r === 0 || r === rows-1 || c === 0 || c === cols-1) {
              grid[r][c] = 1; // border walls
            } else {
              grid[r][c] = 0;
            }
          }
        }
        grid[start.row][start.col] = 0;
        grid[end.row][end.col] = 0;
        visited = [];
        solution = [];
        drawMaze();
      }
      
      // resize grid
      function resizeGrid() {
        rows = parseInt(rowsSlider.value);
        cols = parseInt(colsSlider.value);
        cellSize = Math.min(Math.floor(canvas.width / cols), Math.floor(canvas.height / rows));
        
        // adjust start and end
        start.row = Math.min(start.row, rows-2);
        start.col = Math.min(start.col, cols-2);
        end.row = Math.min(end.row, rows-2);
        end.col = Math.min(end.col, cols-2);
        
        initGrid(rows, cols, 0);
        // add border walls
        for (let r = 0; r < rows; r++) {
          grid[r][0] = 1;
          grid[r][cols-1] = 1;
        }
        for (let c = 0; c < cols; c++) {
          grid[0][c] = 1;
          grid[rows-1][c] = 1;
        }
        grid[start.row][start.col] = 0;
        grid[end.row][end.col] = 0;
        drawMaze();
      }
      
      // event listeners
      rowsSlider.addEventListener('input', () => {
        rowsVal.innerText = rowsSlider.value;
        resizeGrid();
      });
      
      colsSlider.addEventListener('input', () => {
        colsVal.innerText = colsSlider.value;
        resizeGrid();
      });
      
      generateDFS.addEventListener('click', generateDFSMaze);
      generatePrim.addEventListener('click', generatePrimMaze);
      clearWalls.addEventListener('click', clearWallsFn);
      addRandomWalls.addEventListener('click', addRandomWallsFn);
      resetSolution.addEventListener('click', resetSolutionFn);
      
      solveBtn.addEventListener('click', () => {
        if (currentAlgo === 'dfs') solveDFS();
        else if (currentAlgo === 'bfs') solveBFS();
        else if (currentAlgo === 'astar') solveAStar();
      });
      
      algoBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          algoBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentAlgo = btn.dataset.algo;
        });
      });
      
      // click on canvas to set start/end (shift+click for end)
      canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        const mouseX = (e.clientX - rect.left) * scaleX;
        const mouseY = (e.clientY - rect.top) * scaleY;
        
        const col = Math.floor(mouseX / cellSize);
        const row = Math.floor(mouseY / cellSize);
        
        if (row >= 0 && row < rows && col >= 0 && col < cols) {
          if (e.shiftKey) {
            // set end
            if (grid[row][col] === 0) {
              end.row = row;
              end.col = col;
            }
          } else {
            // set start
            if (grid[row][col] === 0) {
              start.row = row;
              start.col = col;
            }
          }
          resetSolutionFn();
          drawMaze();
        }
      });
      
      // initialize
      initGrid(rows, cols, 0);
      // add border walls
      for (let r = 0; r < rows; r++) {
        grid[r][0] = 1;
        grid[r][cols-1] = 1;
      }
      for (let c = 0; c < cols; c++) {
        grid[0][c] = 1;
        grid[rows-1][c] = 1;
      }
      grid[start.row][start.col] = 0;
      grid[end.row][end.col] = 0;
      drawMaze();
    })();
  </script>
</body>
</html>