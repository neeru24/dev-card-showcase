<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‚úß cartoonizer ¬∑ toon filter UI</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(145deg, #232d34, #17242b);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
      padding: 1.5rem;
    }

    .cartoon-card {
      max-width: 1300px;
      width: 100%;
      background: rgba(28, 45, 51, 0.8);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 200, 130, 0.3);
      border-radius: 3.2rem;
      padding: 2.5rem 2.5rem;
      box-shadow: 0 35px 60px -20px black, inset 0 1px 4px #e5b57060;
    }

    h1 {
      font-size: 2.8rem;
      font-weight: 600;
      background: linear-gradient(135deg, #fad6a0, #fdcd8a);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.2rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    h1 span {
      background: #2c4a50;
      font-size: 1.2rem;
      font-weight: 500;
      padding: 0.2rem 1.8rem;
      border-radius: 60px;
      color: #fad09c;
      border: 1px solid #cfa05e;
      -webkit-text-fill-color: #ffe2b7;
    }

    .sub {
      color: #cbbea2;
      margin-bottom: 2.2rem;
      font-size: 1.1rem;
      border-left: 4px solid #f1b56b;
      padding-left: 1.4rem;
    }

    /* main two-column */
    .workspace {
      display: grid;
      grid-template-columns: 1.1fr 1.9fr;
      gap: 2rem;
    }

    /* left panel ‚Äì controls */
    .control-panel {
      background: #1f3b42;
      border-radius: 2.5rem;
      padding: 2rem 1.8rem;
      border: 1px solid #bb9b63;
      box-shadow: inset 0 2px 5px #0e262c, 0 15px 25px -12px black;
    }

    .control-group {
      margin-bottom: 2rem;
    }
    .control-group h3 {
      color: #fdcd9f;
      font-weight: 400;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      font-size: 0.9rem;
      border-bottom: 1px dashed #b58f54;
      padding-bottom: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .slider-item {
      margin-bottom: 1.4rem;
    }
    .slider-item label {
      display: flex;
      justify-content: space-between;
      color: #ecdbbb;
      font-size: 1rem;
      margin-bottom: 0.3rem;
    }
    .slider-item input[type=range] {
      width: 100%;
      height: 8px;
      background: #15414b;
      border-radius: 20px;
      -webkit-appearance: none;
    }
    .slider-item input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 22px;
      height: 22px;
      background: #f1b45a;
      border-radius: 50%;
      border: 2px solid #fff1d2;
      cursor: grab;
      box-shadow: 0 4px 8px black;
    }
    .value-badge {
      background: #1d4d50;
      padding: 0.2rem 1rem;
      border-radius: 30px;
      font-size: 0.85rem;
      color: #ffdaa8;
    }

    .checkbox-item {
      display: flex;
      align-items: center;
      gap: 0.8rem;
      color: #f0dbb8;
      margin: 1.2rem 0;
    }
    .checkbox-item input {
      width: 22px;
      height: 22px;
      accent-color: #f0b45a;
    }

    .sample-images {
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
      margin-top: 1.8rem;
    }
    .sample-btn {
      background: #1d4a4f;
      border: 1px solid #b59359;
      color: #ffe1b9;
      padding: 0.5rem 1.2rem;
      border-radius: 40px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: 0.1s;
    }
    .sample-btn:hover {
      background: #2b646b;
      border-color: #e7b46b;
    }

    /* right side ‚Äì preview & canvas */
    .preview-panel {
      background: #1c373f;
      border-radius: 2.5rem;
      padding: 1.8rem;
      border: 1px solid #cf9f60;
      box-shadow: 0 15px 25px -15px black;
    }

    .canvas-area {
      background: #102e36;
      border-radius: 2rem;
      padding: 1rem;
      border: 1px solid #af8b52;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .image-container {
      display: flex;
      justify-content: center;
      width: 100%;
      min-height: 280px;
      align-items: center;
    }

    canvas {
      max-width: 100%;
      height: auto;
      border-radius: 2rem;
      box-shadow: 0 10px 18px -5px black;
      background: #2c504f;
      display: block;
    }

    .upload-area {
      margin: 1.2rem 0 0.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
    }
    .upload-btn {
      background: #e5aa5f;
      border: none;
      color: #1e3a3a;
      font-weight: 600;
      padding: 0.7rem 1.8rem;
      border-radius: 60px;
      cursor: pointer;
      font-size: 0.95rem;
      border: 1px solid #fad49c;
    }
    .upload-btn:hover {
      background: #f5bc6e;
    }
    .filename {
      color: #fad9a3;
      font-size: 0.9rem;
    }

    .action-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 1.8rem;
    }
    .download-btn {
      background: #2c5757;
      border: 1px solid #d7a35b;
      color: #ffe8c7;
      padding: 0.8rem 2rem;
      border-radius: 50px;
      font-weight: 500;
      cursor: pointer;
    }
    .reset-btn {
      background: #3b4340;
      border: 1px solid #b48b4b;
      color: #fadbb2;
      padding: 0.8rem 2rem;
      border-radius: 50px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="cartoon-card">
    <h1>
      ‚ú¶ cartoonizer UI
      <span>toon filter</span>
    </h1>
    <div class="sub">edge darken ¬∑ quantize ¬∑ smooth ‚Äì real‚Äëtime preview</div>

    <div class="workspace">
      <!-- left controls -->
      <div class="control-panel">
        <div class="control-group">
          <h3>üé® CARTOON FX</h3>
          <div class="slider-item">
            <label>edge strength <span id="edgeVal" class="value-badge">2.0</span></label>
            <input type="range" id="edgeStrength" min="0" max="5" step="0.1" value="2.0">
          </div>
          <div class="slider-item">
            <label>color levels <span id="levelsVal" class="value-badge">6</span></label>
            <input type="range" id="colorLevels" min="2" max="20" step="1" value="6">
          </div>
          <div class="slider-item">
            <label>smooth passes <span id="smoothVal" class="value-badge">1</span></label>
            <input type="range" id="smoothPasses" min="0" max="3" step="1" value="1">
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="invertEdge" checked>
            <label>dark edges (sobel style)</label>
          </div>
        </div>

        <div class="control-group">
          <h3>üñºÔ∏è SAMPLE / RESET</h3>
          <div class="sample-images">
            <button class="sample-btn" id="samplePortrait">üßë portrait</button>
            <button class="sample-btn" id="sampleLandscape">üèûÔ∏è landscape</button>
            <button class="sample-btn" id="sampleObject">üçé object</button>
          </div>
          <div style="margin-top:1.2rem;">
            <button class="sample-btn" id="resetDefaultsBtn">‚ü≤ reset filters</button>
          </div>
        </div>
      </div>

      <!-- right preview -->
      <div class="preview-panel">
        <div class="canvas-area">
          <div class="image-container">
            <canvas id="previewCanvas" width="400" height="300"></canvas>
          </div>
          <div class="upload-area">
            <label for="fileInput" class="upload-btn">üìÇ upload image</label>
            <input type="file" id="fileInput" accept="image/*" style="display:none;">
            <span class="filename" id="fileNameDisplay">default sample</span>
          </div>
        </div>

        <div class="action-buttons">
          <button class="download-btn" id="downloadBtn">üíæ download cartoon</button>
          <button class="reset-btn" id="refreshOriginal">‚Ü∫ revert to original</button>
        </div>
        <p style="color:#b8b087; margin-top:0.8rem; font-size:0.85rem;">‚ö° webcam not needed ‚Äî real‚Äëtime cartoonization</p>
      </div>
    </div>
  </div>

  <script>
    (function() {
      // ----- canvas & ui elements -----
      const canvas = document.getElementById('previewCanvas');
      const ctx = canvas.getContext('2d', { willReadFrequently: true });

      // sliders & displays
      const edgeStrength = document.getElementById('edgeStrength');
      const edgeVal = document.getElementById('edgeVal');
      const colorLevels = document.getElementById('colorLevels');
      const levelsVal = document.getElementById('levelsVal');
      const smoothPasses = document.getElementById('smoothPasses');
      const smoothVal = document.getElementById('smoothVal');
      const invertEdgeCheck = document.getElementById('invertEdge');

      // buttons
      const fileInput = document.getElementById('fileInput');
      const fileNameDisplay = document.getElementById('fileNameDisplay');
      const samplePortrait = document.getElementById('samplePortrait');
      const sampleLandscape = document.getElementById('sampleLandscape');
      const sampleObject = document.getElementById('sampleObject');
      const resetDefaultsBtn = document.getElementById('resetDefaultsBtn');
      const downloadBtn = document.getElementById('downloadBtn');
      const refreshOriginal = document.getElementById('refreshOriginal');

      // internal state
      let originalImageData = null;           // store original image data (after upload/default)
      let originalWidth = 400, originalHeight = 300;
      let currentFileName = 'default sample';

      // ----- default sample (built-in colorful pattern) -----
      function drawDefaultSample() {
        canvas.width = 400; canvas.height = 300;
        ctx.clearRect(0, 0, 400, 300);
        // draw a fun test image: gradients, shapes, face-like
        const grd = ctx.createLinearGradient(0, 0, 400, 300);
        grd.addColorStop(0, '#f7c978');
        grd.addColorStop(0.5, '#c99e60');
        grd.addColorStop(1, '#8f6e4c');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, 400, 300);
        // eye / mouth shapes
        ctx.fillStyle = '#a6521c';
        ctx.beginPath();
        ctx.arc(120, 120, 35, 0, 2*Math.PI);
        ctx.fill();
        ctx.fillStyle = '#d47b42';
        ctx.beginPath();
        ctx.arc(280, 120, 40, 0, 2*Math.PI);
        ctx.fill();
        ctx.fillStyle = '#302012';
        ctx.beginPath();
        ctx.arc(130, 130, 12, 0, 2*Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(290, 130, 14, 0, 2*Math.PI);
        ctx.fill();

        ctx.fillStyle = '#bc693a';
        ctx.beginPath();
        ctx.ellipse(200, 200, 70, 35, 0, 0, 2*Math.PI);
        ctx.fill();
        // store as original
        originalImageData = ctx.getImageData(0, 0, 400, 300);
        originalWidth = 400; originalHeight = 300;
        currentFileName = 'default sample';
        fileNameDisplay.innerText = currentFileName;
        applyCartoon(); // cartoonize initial
      }

      // ----- cartoonization core (simple sobel edge + posterize + smooth) -----
      function applyCartoon() {
        if (!originalImageData) return;

        const edgeW = parseFloat(edgeStrength.value);
        const levels = parseInt(colorLevels.value, 10);
        const smooth = parseInt(smoothPasses.value, 10);
        const invert = invertEdgeCheck.checked; // true = dark edges

        edgeVal.innerText = edgeW.toFixed(1);
        levelsVal.innerText = levels;
        smoothVal.innerText = smooth;

        // copy original data
        const srcData = new Uint8ClampedArray(originalImageData.data);
        const w = originalWidth, h = originalHeight;
        const dstData = new Uint8ClampedArray(srcData.length);

        // 1. posterize (simple quantization)
        const step = 255 / (levels - 1);
        for (let i = 0; i < srcData.length; i += 4) {
          let r = srcData[i];
          let g = srcData[i+1];
          let b = srcData[i+2];
          // quantize each channel independently (posterize)
          dstData[i] = Math.round(Math.round(r / step) * step);
          dstData[i+1] = Math.round(Math.round(g / step) * step);
          dstData[i+2] = Math.round(Math.round(b / step) * step);
          dstData[i+3] = srcData[i+3]; // alpha
        }

        // 2. simple edge detection (sobel-like intensity difference) on luminance of original
        const gray = new Uint8ClampedArray(w * h);
        for (let i = 0; i < srcData.length; i += 4) {
          const r = srcData[i];
          const g = srcData[i+1];
          const b = srcData[i+2];
          gray[i/4] = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
        }

        const edgeMap = new Float32Array(w * h).fill(0);
        for (let y = 1; y < h-1; y++) {
          for (let x = 1; x < w-1; x++) {
            const idx = y * w + x;
            // horizontal gradient
            const gx = (gray[(y-1)*w + x-1] + 2*gray[y*w + x-1] + gray[(y+1)*w + x-1]) -
                       (gray[(y-1)*w + x+1] + 2*gray[y*w + x+1] + gray[(y+1)*w + x+1]);
            const gy = (gray[(y-1)*w + x-1] + 2*gray[(y-1)*w + x] + gray[(y-1)*w + x+1]) -
                       (gray[(y+1)*w + x-1] + 2*gray[(y+1)*w + x] + gray[(y+1)*w + x+1]);
            const mag = Math.sqrt(gx*gx + gy*gy) * (edgeW * 0.5); // scaled
            edgeMap[idx] = Math.min(mag, 255);
          }
        }

        // 3. combine: darken edges on quantized image
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const idx = y * w + x;
            const edgeVal = edgeMap[idx] || 0;
            const pIdx = idx * 4;
            if (edgeVal > 8) { // threshold
              if (invert) {
                // darken: reduce rgb
                dstData[pIdx] = Math.max(0, dstData[pIdx] - edgeVal * 0.8);
                dstData[pIdx+1] = Math.max(0, dstData[pIdx+1] - edgeVal * 0.8);
                dstData[pIdx+2] = Math.max(0, dstData[pIdx+2] - edgeVal * 0.8);
              } else {
                // lighten (inverted) ‚Äì just for fun, but we keep dark edges by default
                dstData[pIdx] = Math.min(255, dstData[pIdx] + edgeVal * 0.3);
                dstData[pIdx+1] = Math.min(255, dstData[pIdx+1] + edgeVal * 0.3);
                dstData[pIdx+2] = Math.min(255, dstData[pIdx+2] + edgeVal * 0.3);
              }
            }
          }
        }

        // 4. simple smoothing (box blur, number of passes)
        let finalData = dstData;
        for (let pass = 0; pass < smooth; pass++) {
          const temp = new Uint8ClampedArray(finalData.length);
          for (let y = 1; y < h-1; y++) {
            for (let x = 1; x < w-1; x++) {
              const i = (y * w + x) * 4;
              let r=0,g=0,b=0; let count=0;
              for (let dy = -1; dy <=1; dy++) {
                for (let dx = -1; dx <=1; dx++) {
                  const ni = ((y+dy) * w + (x+dx)) * 4;
                  r += finalData[ni];
                  g += finalData[ni+1];
                  b += finalData[ni+2];
                  count++;
                }
              }
              temp[i] = r/count; temp[i+1]=g/count; temp[i+2]=b/count; temp[i+3]=finalData[i+3];
            }
          }
          // copy edges
          for (let i = 0; i < finalData.length; i+=4) {
            if (temp[i] !== undefined) {
              finalData[i]=temp[i]; finalData[i+1]=temp[i+1]; finalData[i+2]=temp[i+2];
            }
          }
        }

        const outImage = new ImageData(finalData, w, h);
        ctx.putImageData(outImage, 0, 0);
      }

      // ----- load image from file or sample -----
      function loadImageFromFile(file) {
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            // resize canvas to fit while preserving aspect (max 500 width)
            const maxW = 500, maxH = 400;
            let w = img.width, h = img.height;
            if (w > maxW) { h = (maxW / w) * h; w = maxW; }
            if (h > maxH) { w = (maxH / h) * w; h = maxH; }
            canvas.width = Math.floor(w); canvas.height = Math.floor(h);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            originalWidth = canvas.width; originalHeight = canvas.height;
            currentFileName = file.name;
            fileNameDisplay.innerText = currentFileName;
            applyCartoon();
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      }

      // load sample via URL (predefined images ‚Äì we use emoji placeholders / create pattern)
      function loadSample(type) {
        canvas.width = 400; canvas.height = 300;
        ctx.clearRect(0,0,400,300);
        if (type === 'portrait') {
          // stylized face
          ctx.fillStyle = '#d69d5e'; ctx.fillRect(0,0,400,300);
          ctx.fillStyle = '#b57a4a'; ctx.beginPath(); ctx.ellipse(200,130,100,130,0,0,2*Math.PI); ctx.fill();
          ctx.fillStyle = '#f0c27b'; ctx.beginPath(); ctx.ellipse(150,100,30,40,0,0,2*Math.PI); ctx.fill();
          ctx.beginPath(); ctx.ellipse(250,100,30,40,0,0,2*Math.PI); ctx.fill();
          ctx.fillStyle = '#421c0c'; ctx.beginPath(); ctx.arc(160,120,8,0,2*Math.PI); ctx.fill();
          ctx.beginPath(); ctx.arc(240,120,8,0,2*Math.PI); ctx.fill();
          ctx.fillStyle = '#ab5f35'; ctx.beginPath(); ctx.ellipse(200,190,40,20,0,0,2*Math.PI); ctx.fill();
        } else if (type === 'landscape') {
          ctx.fillStyle = '#88aa55'; ctx.fillRect(0,150,400,150);
          ctx.fillStyle = '#5d814a'; ctx.fillRect(0,200,400,100);
          ctx.fillStyle = '#3d6f42'; ctx.beginPath(); ctx.arc(80,130,60,0,2*Math.PI); ctx.fill();
          ctx.beginPath(); ctx.arc(300,80,70,0,2*Math.PI); ctx.fill();
          ctx.fillStyle = '#c9ae74'; beginPath(ctx).arc(200,200,30,0,2*Math.PI); ctx.fill(); // rock?
        } else if (type === 'object') {
          ctx.fillStyle = '#cf7f4a'; ctx.fillRect(0,0,400,300);
          ctx.fillStyle = '#a25228'; ctx.beginPath(); ctx.ellipse(200,150,80,100,0,0,2*Math.PI); ctx.fill();
          ctx.fillStyle = '#8b5a2b'; ctx.beginPath(); ctx.arc(200,100,30,0,2*Math.PI); ctx.fill();
        }
        originalImageData = ctx.getImageData(0, 0, 400, 300);
        originalWidth = 400; originalHeight = 300;
        currentFileName = type + ' sample';
        fileNameDisplay.innerText = currentFileName;
        applyCartoon();
      }

      // reset filters to default values
      function resetFilters() {
        edgeStrength.value = '2.0';
        colorLevels.value = '6';
        smoothPasses.value = '1';
        invertEdgeCheck.checked = true;
        applyCartoon();
      }

      // revert to original (without cartoon)
      function revertOriginal() {
        if (originalImageData) {
          ctx.putImageData(originalImageData, 0, 0);
          // but we keep filters, we need to reapply? actually revert means show original, then reapply?
          // we want to see original: just draw original. we can then apply cartoon on demand? we have applyCartoon.
          // revert = show unmodified.
          ctx.putImageData(originalImageData, 0, 0);
          // but we want to keep ability to reapply: we can call applyCartoon after revert? not exactly.
          // better: use a flag. but simple: revert to original (temporarily show original). we'll also set a state.
          // for UX we create separate "refreshOriginal" that shows original.
        }
      }

      // Event listeners
      edgeStrength.addEventListener('input', applyCartoon);
      colorLevels.addEventListener('input', applyCartoon);
      smoothPasses.addEventListener('input', applyCartoon);
      invertEdgeCheck.addEventListener('change', applyCartoon);

      fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) loadImageFromFile(e.target.files[0]);
      });

      samplePortrait.addEventListener('click', () => loadSample('portrait'));
      sampleLandscape.addEventListener('click', () => loadSample('landscape'));
      sampleObject.addEventListener('click', () => loadSample('object'));

      resetDefaultsBtn.addEventListener('click', resetFilters);

      refreshOriginal.addEventListener('click', () => {
        if (originalImageData) {
          ctx.putImageData(originalImageData, 0, 0);
        }
      });

      downloadBtn.addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = 'cartoonized.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
      });

      // init
      drawDefaultSample();
    })();
  </script>
</body>
</html>