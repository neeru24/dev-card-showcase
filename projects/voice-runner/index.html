<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üéôÔ∏è voice runner ¬∑ speak to move</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
    }
    body {
      background: linear-gradient(145deg, #0b1729 0%, #1b2f44 100%);
      min-height: 100vh;
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .game-wrapper {
      background: #213a4f;
      border-radius: 2.5rem;
      padding: 2rem 2rem 2.5rem;
      box-shadow: 0 30px 35px -10px rgba(0,0,0,0.6), inset 0 -3px 8px rgba(0,0,0,0.4), inset 0 3px 5px rgba(255,255,255,0.1);
      border: 1px solid #3d667e;
    }
    .canvas-container {
      display: flex;
      justify-content: center;
      border-radius: 2rem;
      background: #1d3342;
      padding: 12px;
      box-shadow: inset 0 0 0 2px #10212b;
    }
    canvas {
      display: block;
      width: 720px;
      height: 360px;
      border-radius: 1.2rem;
      background: radial-gradient(circle at 50% 30%, #587b92, #2c475a);
      box-shadow: 0 10px 18px black;
      cursor: pointer;
    }
    .control-panel {
      margin-top: 1.8rem;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      justify-content: space-between;
      background: #1b3140;
      padding: 1.2rem 1.8rem;
      border-radius: 4rem;
      border: 1px solid #376279;
    }
    .mic-section {
      display: flex;
      align-items: center;
      gap: 0.8rem;
      flex-wrap: wrap;
    }
    .mic-btn {
      background: #314e61;
      border: none;
      color: white;
      font-size: 2rem;
      width: 64px;
      height: 64px;
      border-radius: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 6px 0 #14222e, 0 8px 12px black;
      transition: 0.08s linear;
      cursor: pointer;
      border: 1px solid #6e9fc7;
    }
    .mic-btn.active {
      background: #44a56b;
      transform: translateY(4px);
      box-shadow: 0 2px 0 #0e2f1d, 0 5px 12px black;
      border-color: #a2f0c4;
    }
    .mic-btn:active {
      transform: translateY(6px);
      box-shadow: 0 0px 0 #14222e, 0 5px 12px black;
    }
    .status-badge {
      background: #0c1c28;
      padding: 0.5rem 1.5rem;
      border-radius: 3rem;
      color: #b1dcfd;
      font-weight: 600;
      font-size: 1.2rem;
      letter-spacing: 1px;
      border: 1px solid #2f6382;
      box-shadow: inset 0 2px 5px #00000055;
      min-width: 180px;
      text-align: center;
    }
    .command-hint {
      background: #0b1b26;
      color: #f5e56b;
      padding: 0.6rem 1.8rem;
      border-radius: 3rem;
      font-size: 1.3rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: inset 0 -2px 0 #3f5564;
      border: 1px solid #ffd966;
    }
    .command-hint span {
      font-size: 1.8rem;
      filter: drop-shadow(0 2px 3px black);
    }
    .move-log {
      background: #1e3343;
      padding: 0.7rem 1.3rem;
      border-radius: 3rem;
      color: #cfecf0;
      font-size: 1.2rem;
      font-weight: 500;
      border: 1px solid #2b6c8a;
      flex: 1;
      min-width: 200px;
      text-align: center;
      box-shadow: inset 0 0 10px #0d1f2b;
    }
    .fallback-note {
      color: #c7dbe6;
      margin-top: 0.7rem;
      text-align: center;
      font-size: 0.95rem;
    }
    .fallback-note button {
      background: none;
      border: 1px solid #5685a3;
      color: #ffea9f;
      padding: 0.2rem 1rem;
      border-radius: 2rem;
      font-size: 0.9rem;
      margin-left: 0.6rem;
      cursor: pointer;
    }
  </style>
</head>
<body>
<div class="game-wrapper">
  <div class="canvas-container">
    <canvas id="gameCanvas" width="720" height="360"></canvas>
  </div>

  <div class="control-panel">
    <div class="mic-section">
      <button class="mic-btn" id="micButton" title="hold to listen / click to toggle (always on)">üé§</button>
      <div class="status-badge" id="listeningStatus">‚ö™ idle</div>
    </div>
    <div class="command-hint">
      <span>üó£Ô∏è</span> say: left / right / jump / stop
    </div>
    <div class="move-log" id="actionLog">ready for voice...</div>
  </div>

  <div class="fallback-note">
    üí° use chrome / edge ¬∑ if stuck click <button id="forceStopBtn">‚èπÔ∏è force stop</button> or tap canvas
  </div>
</div>

<script>
  (function() {
    // --- canvas & character ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const actionLog = document.getElementById('actionLog');
    const listeningStatus = document.getElementById('listeningStatus');
    const micBtn = document.getElementById('micButton');

    // character physics (simple ground at y=300)
    const GROUND_Y = 300;
    const CHAR_WIDTH = 32;
    const CHAR_HEIGHT = 42;
    let charX = 140;               // start position
    let charY = GROUND_Y - CHAR_HEIGHT; // standing on ground
    let vy = 0;
    let isOnGround = true;
    const GRAVITY = 0.5;
    const JUMP_FORCE = -10;
    const MOVE_STEP = 15;          // pixels per voice command
    const MIN_X = 30;
    const MAX_X = 690 - CHAR_WIDTH; // right boundary

    // --- voice recognition setup ---
    let recognition = null;
    let isListening = false;        // are we currently capturing voice?
    let forcedStop = false;         // just for ui feedback

    // recent command (for display)
    let lastCommand = '‚Äî';

    // speech recognition support
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      listeningStatus.innerHTML = '‚ùå speech not supported';
      micBtn.style.opacity = '0.4';
      actionLog.innerText = 'üö´ browser lacks speech recognition';
    } else {
      recognition = new SpeechRecognition();
      recognition.continuous = true;      // keep listening (but we restart on end)
      recognition.interimResults = false; // only final transcripts
      recognition.lang = 'en-US';
      recognition.maxAlternatives = 1;

      // --- handle results ---
      recognition.onresult = (event) => {
        // take the last result (in case of multiple)
        const last = event.results[event.results.length - 1];
        if (last.isFinal) {
          const transcript = last[0].transcript.trim().toLowerCase();
          processVoiceCommand(transcript);
        }
      };

      recognition.onend = () => {
        // if we are still supposed to be listening (not manually stopped) restart
        if (isListening && !forcedStop) {
          try {
            recognition.start();
          } catch (e) {
            console.warn('restart failed', e);
            isListening = false;
            updateMicUI();
          }
        } else {
          // normal stop (user clicked or forced)
          isListening = false;
          updateMicUI();
        }
      };

      recognition.onerror = (e) => {
        console.warn('recognition error:', e.error);
        if (e.error === 'not-allowed') {
          listeningStatus.innerHTML = 'üîá microphone blocked';
          isListening = false;
          updateMicUI();
        } else if (e.error === 'no-speech') {
          // ignore, just wait for next try
        } else {
          // other errors: stop and reset ui
          isListening = false;
          updateMicUI();
        }
      };
    }

    // --- process spoken command ---
    function processVoiceCommand(text) {
      let action = 'ü§î unknown';
      let moved = false;

      // simple keyword matching
      if (text.includes('left') || text.includes('move left') || text.includes('go left')) {
        charX = Math.max(MIN_X, charX - MOVE_STEP);
        action = '‚¨ÖÔ∏è left';
        moved = true;
      }
      else if (text.includes('right') || text.includes('move right') || text.includes('go right')) {
        charX = Math.min(MAX_X, charX + MOVE_STEP);
        action = '‚û°Ô∏è right';
        moved = true;
      }
      else if (text.includes('jump') || text.includes('jump now') || text.includes('leap')) {
        if (isOnGround) {
          vy = JUMP_FORCE;
          isOnGround = false;
          action = 'ü¶ò jump';
          moved = true;
        } else {
          action = '‚è´ jump (already air)';
        }
      }
      else if (text.includes('stop') || text.includes('halt') || text.includes('stay')) {
        // does nothing, just logs
        action = '‚úã stop';
        moved = true;
      }
      else {
        action = `‚ùì "${text}"`;
      }

      lastCommand = action;
      actionLog.innerText = `üó£Ô∏è ${action}`;
      if (moved) {
        // give a little feedback flash
        micBtn.style.backgroundColor = '#b8e0b8';
        setTimeout(() => { micBtn.style.backgroundColor = ''; }, 120);
      }
    }

    // --- UI update for microphone button & status ---
    function updateMicUI() {
      if (isListening) {
        micBtn.classList.add('active');
        listeningStatus.innerHTML = 'üéôÔ∏è listening ...';
      } else {
        micBtn.classList.remove('active');
        if (recognition && !SpeechRecognition) {
          listeningStatus.innerHTML = '‚ö™ idle';
        } else if (recognition === null) {
          listeningStatus.innerHTML = '‚õî unsupported';
        } else {
          listeningStatus.innerHTML = '‚ö™ idle';
        }
      }
    }

    // toggle listening
    function toggleListening() {
      if (!recognition) {
        alert('Speech recognition not available. Try Chrome / Edge.');
        return;
      }

      if (isListening) {
        // turn off
        forcedStop = false;
        isListening = false;
        try {
          recognition.stop();
        } catch (e) {}
      } else {
        // turn on
        forcedStop = false;
        isListening = true;
        try {
          recognition.start();
          actionLog.innerText = 'üé§ microphone active ...';
        } catch (e) {
          console.warn('start failed', e);
          isListening = false;
          if (e.message.includes('already started')) {
            // try to restart
            try { recognition.stop(); } catch (ex) {}
            setTimeout(() => {
              if (isListening) {
                try { recognition.start(); } catch (ex) {}
              }
            }, 100);
          }
        }
      }
      updateMicUI();
    }

    // force stop (cleanup)
    function forceStopListening() {
      forcedStop = true;
      if (recognition && isListening) {
        try {
          recognition.stop();
        } catch (e) {}
      }
      isListening = false;
      updateMicUI();
      actionLog.innerText = 'üõë voice stopped (manual)';
    }

    // --- drawing ---
    function drawScene() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // sky gradient
      const sky = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
      sky.addColorStop(0, '#a6d9fb');
      sky.addColorStop(0.7, '#e0f0fa');
      ctx.fillStyle = sky;
      ctx.fillRect(0, 0, canvas.width, GROUND_Y - 5);

      // ground
      ctx.fillStyle = '#4f7942';
      ctx.fillRect(0, GROUND_Y, canvas.width, 60);
      // grass detail
      ctx.fillStyle = '#6f9e5f';
      ctx.fillRect(0, GROUND_Y, canvas.width, 8);
      ctx.fillStyle = '#9fbb73';
      for (let i = 0; i < 12; i++) {
        ctx.fillRect(i * 60 + 10, GROUND_Y - 2, 30, 6);
      }

      // platform markings
      ctx.shadowColor = '#00000040';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetY = 2;

      // character (simple round boy)
      ctx.shadowColor = '#1e2e24';
      ctx.shadowBlur = 12;

      // body
      ctx.fillStyle = '#fdd998';
      ctx.beginPath();
      ctx.roundRect(charX, charY, CHAR_WIDTH, CHAR_HEIGHT, 12);
      ctx.fill();

      // belt / detail
      ctx.fillStyle = '#b86f2c';
      ctx.beginPath();
      ctx.roundRect(charX + 4, charY + 22, 24, 8, 6);
      ctx.fill();

      // eyes
      ctx.fillStyle = '#2f1e0e';
      ctx.beginPath();
      ctx.arc(charX + 8, charY + 12, 4, 0, Math.PI * 2);
      ctx.arc(charX + 24, charY + 12, 4, 0, Math.PI * 2);
      ctx.fill();

      // eye highlights
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(charX + 6, charY + 10, 1.5, 0, Math.PI * 2);
      ctx.arc(charX + 22, charY + 10, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // mouth (depending on ground)
      ctx.beginPath();
      ctx.strokeStyle = '#592f0b';
      ctx.lineWidth = 2;
      if (isOnGround) {
        ctx.arc(charX + 16, charY + 26, 6, 0.1, Math.PI - 0.1);
      } else {
        ctx.arc(charX + 16, charY + 20, 5, 0, Math.PI);
      }
      ctx.stroke();

      ctx.shadowBlur = 0;
      ctx.shadowOffsetY = 0;
    }

    // helper canvas rounding
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
      if (w < 2 * r) r = w / 2;
      if (h < 2 * r) r = h / 2;
      this.moveTo(x + r, y);
      this.lineTo(x + w - r, y);
      this.quadraticCurveTo(x + w, y, x + w, y + r);
      this.lineTo(x + w, y + h - r);
      this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      this.lineTo(x + r, y + h);
      this.quadraticCurveTo(x, y + h, x, y + h - r);
      this.lineTo(x, y + r);
      this.quadraticCurveTo(x, y, x + r, y);
      return this;
    };

    // --- physics update ---
    function update() {
      if (!isOnGround) {
        vy += GRAVITY;
        charY += vy;
      }

      // ground collision
      if (charY >= GROUND_Y - CHAR_HEIGHT) {
        charY = GROUND_Y - CHAR_HEIGHT;
        vy = 0;
        isOnGround = true;
      } else {
        isOnGround = false;
      }

      // clamp horizontal (redundant but safe)
      charX = Math.max(MIN_X, Math.min(MAX_X, charX));
    }

    // animation loop
    function gameLoop() {
      update();
      drawScene();
      requestAnimationFrame(gameLoop);
    }
    gameLoop();

    // --- event listeners ---
    micBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleListening();
    });

    document.getElementById('forceStopBtn').addEventListener('click', () => {
      forceStopListening();
    });

    // optional: click on canvas to stop listening (usability)
    canvas.addEventListener('click', () => {
      if (isListening) {
        forceStopListening();
        actionLog.innerText = 'üñêÔ∏è listening stopped (canvas tap)';
      } else {
        // start listening on canvas tap? better toggle via mic, but we can hint
        actionLog.innerText = 'üé§ use mic button';
      }
    });

    // clean up on page hide
    window.addEventListener('beforeunload', () => {
      if (recognition && isListening) {
        try { recognition.stop(); } catch (e) {}
      }
    });

    // initial draw
    drawScene();
    updateMicUI();

    // add a fallback for manual command (if voice not works, but we don't need)
    // just show that it's ready
    actionLog.innerText = 'say left / right / jump / stop';
  })();
</script>
</body>
</html>