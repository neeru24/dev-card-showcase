<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸŽ² virtual dice game Â· hold & risk</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, sans-serif;
        }

        body {
            min-height: 100vh;
            background: linear-gradient(145deg, #1f3527 0%, #2d4735 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
        }

        .game-table {
            max-width: 900px;
            width: 100%;
            background: #1d6b3c;
            background: radial-gradient(circle at 30% 30%, #2b8c4a, #115e2b);
            border-radius: 5rem 5rem 4rem 4rem;
            padding: 2.5rem 2rem 2.8rem;
            box-shadow: 0 35px 40px -15px #0f321b, 0 0 0 2px #c0b56b inset, 0 0 0 6px #3d2f1b inset;
            border: 6px solid #ac874b;
        }

        /* scores header */
        .scoreboard {
            display: flex;
            justify-content: space-between;
            background: #1f4927d9;
            backdrop-filter: blur(4px);
            border-radius: 120px;
            padding: 0.8rem 2.5rem;
            margin-bottom: 2.2rem;
            border: 2px solid #ebcb9c;
            box-shadow: 0 8px 0 #3e2f19;
            color: #faf0ce;
        }

        .player-tag {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 1.8rem;
            font-weight: 600;
            text-shadow: 2px 2px 0 #274e17;
        }

        .player-tag span {
            background: #fdefb9;
            color: #1f4a28;
            padding: 0.3rem 1.5rem;
            border-radius: 60px;
            font-size: 2rem;
            font-weight: 700;
            box-shadow: inset 0 -3px 0 #927b48;
            border: 1px solid #ffecb3;
        }

        .computer-tag {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 1.8rem;
            font-weight: 600;
            color: #feedb7;
        }

        .computer-tag span {
            background: #2e2b1f;
            color: #f9e7b3;
            padding: 0.3rem 1.5rem;
            border-radius: 60px;
            font-size: 2rem;
            font-weight: 700;
            box-shadow: inset 0 -3px 0 #7b6f48;
            border: 1px solid #b6944c;
        }

        /* main dice area */
        .dice-stage {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            gap: 3rem;
            margin: 1rem 0 2.5rem;
        }

        .dice-card {
            background: #fffae6;
            border-radius: 3rem;
            padding: 1rem 1.8rem 1.8rem;
            box-shadow: 0 20px 0 #7b5d34, 0 25px 30px #0e3018;
            border: 3px solid #ffdd99;
            text-align: center;
            min-width: 180px;
        }

        .dice-label {
            font-size: 1.4rem;
            color: #5f3f1a;
            font-weight: 600;
            background: #fed996;
            display: inline-block;
            padding: 0.3rem 2rem;
            border-radius: 40px;
            margin-top: -1.2rem;
            margin-bottom: 1rem;
            border: 1px solid #b37b38;
        }

        .dice-value {
            font-size: 8rem;
            line-height: 1;
            font-weight: 700;
            color: #2d2d1c;
            text-shadow: 4px 4px 0 #c9a259;
            background: #fff3d1;
            border-radius: 80px;
            padding: 0.3rem 0.2rem;
            margin: 0.2rem 0;
        }

        .current-roll {
            background: #2a6b37;
            border-radius: 60px;
            padding: 0.5rem 2rem;
            color: #fff1bb;
            font-size: 1.6rem;
            font-weight: 600;
            text-align: center;
            display: inline-block;
            margin: 0 auto 1rem;
            border: 2px solid #ffdd99;
        }

        .turn-indicator {
            font-size: 1.5rem;
            background: #121c0f;
            color: #fbe593;
            padding: 0.5rem 2rem;
            border-radius: 60px;
            border: 2px solid #f5c27b;
            text-align: center;
            margin: 1rem 0 1.8rem;
        }

        /* action buttons */
        .actions {
            display: flex;
            justify-content: center;
            gap: 25px;
            flex-wrap: wrap;
            margin-bottom: 2rem;
        }

        .game-btn {
            background: #edb768;
            border: none;
            font-size: 1.9rem;
            font-weight: 700;
            padding: 1rem 2.2rem;
            border-radius: 60px;
            box-shadow: 0 8px 0 #8b6220, 0 6px 18px black;
            cursor: pointer;
            transition: 0.05s linear;
            color: #2d341b;
            border: 2px solid #ffe49e;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .game-btn:active {
            transform: translateY(6px);
            box-shadow: 0 2px 0 #6f4e21, 0 6px 18px black;
        }

        .game-btn:disabled {
            opacity: 0.5;
            transform: translateY(4px);
            box-shadow: 0 4px 0 #5a3f1e;
            pointer-events: none;
        }

        .reset-btn {
            background: #386651;
            box-shadow: 0 7px 0 #1d4029;
            color: #f9efcb;
            font-size: 1.5rem;
        }

        .message-area {
            background: #362f1fd4;
            border-radius: 40px;
            padding: 1rem 2rem;
            color: #fde6ae;
            font-size: 1.4rem;
            font-weight: 500;
            text-align: center;
            border: 2px solid #bda465;
            backdrop-filter: blur(2px);
        }

        .rules {
            font-size: 1rem;
            margin-top: 1.5rem;
            color: #d6d19a;
            text-align: center;
        }
    </style>
</head>
<body>
<div class="game-table">
    <div class="scoreboard">
        <div class="player-tag">ðŸ§‘ YOU <span id="playerScore">0</span></div>
        <div class="computer-tag"><span id="computerScore">0</span> ðŸ¤– CPU</div>
    </div>

    <!-- dice display -->
    <div class="dice-stage">
        <div class="dice-card">
            <div class="dice-label">your die</div>
            <div class="dice-value" id="playerDie">âš€</div>
        </div>
        <div class="dice-card">
            <div class="dice-label">cpu die</div>
            <div class="dice-value" id="computerDie">âš€</div>
        </div>
    </div>

    <!-- turn & current round stakes -->
    <div class="current-roll" id="roundPot">round pot: 0</div>
    <div class="turn-indicator" id="turnMessage">ðŸŽ² your turn Â· roll or hold</div>

    <!-- main controls -->
    <div class="actions">
        <button class="game-btn" id="rollBtn">ðŸŽ² ROLL</button>
        <button class="game-btn" id="holdBtn">âœ‹ HOLD</button>
        <button class="game-btn reset-btn" id="resetBtn">âŸ² NEW GAME</button>
    </div>

    <!-- dynamic message -->
    <div class="message-area" id="gameMessage">Roll the dice to begin</div>
    <div class="rules">âš¡ Hold to bank your round score. If you roll a 1, you lose the round points and turn passes.</div>
</div>

<script>
    (function() {
        // ---------- game state ----------
        let playerScore = 0;          // permanent score
        let computerScore = 0;
        let roundScore = 0;           // unbanked points for current player
        let currentTurn = 'player';    // 'player' or 'computer'
        let gameOver = false;

        // DOM elements
        const playerScoreSpan = document.getElementById('playerScore');
        const computerScoreSpan = document.getElementById('computerScore');
        const playerDieDiv = document.getElementById('playerDie');
        const computerDieDiv = document.getElementById('computerDie');
        const roundPotDiv = document.getElementById('roundPot');
        const turnMessageDiv = document.getElementById('turnMessage');
        const gameMessageDiv = document.getElementById('gameMessage');

        const rollBtn = document.getElementById('rollBtn');
        const holdBtn = document.getElementById('holdBtn');
        const resetBtn = document.getElementById('resetBtn');

        // helper: convert die value (1-6) to unicode symbol (simple representation)
        function getDieFace(value) {
            const faces = ['âš€', 'âš', 'âš‚', 'âšƒ', 'âš„', 'âš…'];
            return faces[value - 1] || 'âš€';
        }

        // update UI scores, dice, pot
        function refreshUI(playerDieValue = 1, computerDieValue = 1) {
            playerScoreSpan.textContent = playerScore;
            computerScoreSpan.textContent = computerScore;
            roundPotDiv.textContent = `round pot: ${roundScore}`;

            // show dice faces (only update if provided, but keep displayed)
            playerDieDiv.textContent = getDieFace(playerDieValue);
            computerDieDiv.textContent = getDieFace(computerDieValue);

            // turn indicator and message
            if (gameOver) {
                turnMessageDiv.textContent = 'ðŸ GAME OVER';
            } else {
                turnMessageDiv.textContent = currentTurn === 'player' ? 'ðŸŽ² your turn Â· roll or hold' : 'ðŸ¤– computer thinking ...';
            }
        }

        // random 1-6
        function rollDie() {
            return Math.floor(Math.random() * 6) + 1;
        }

        // computer turn logic (simple: roll until risk > 5 or hold if round score >= 8)
        function computerTurn() {
            if (gameOver || currentTurn !== 'computer') return;

            function computerMove() {
                if (gameOver || currentTurn !== 'computer') return;

                // computer decision: hold if round score >= 8, else roll with 70% chance, but also sometimes hold if score>4 randomly?
                // we'll implement a simple AI: if round score >= 9, always hold; otherwise 70% roll, 30% hold (but risk of rolling 1)
                // but to make it interesting and keep turn moving, we use a small timeout.

                if (roundScore >= 9) {
                    // computer holds
                    holdComputer();
                    return;
                }

                // random decision: 70% roll, 30% hold (if roundScore>0, else must roll)
                if (roundScore === 0) {
                    // must roll (can't hold zero)
                    performComputerRoll();
                } else {
                    const decision = Math.random();
                    if (decision < 0.7) {  // 70% roll
                        performComputerRoll();
                    } else {
                        holdComputer();
                    }
                }
            }

            function performComputerRoll() {
                // roll for computer (as current player)
                const die = rollDie();
                // display computer die (the rolling player)
                if (currentTurn === 'computer') {
                    computerDieDiv.textContent = getDieFace(die);  // computer's own die
                }

                if (die === 1) {
                    // lose round score, switch turn to player
                    roundScore = 0;
                    gameMessageDiv.textContent = 'ðŸ’¥ Computer rolled 1! Round lost. Your turn.';
                    currentTurn = 'player';
                    refreshUI(1, die);  // keep player die as previous? we don't have player die now; we can set player die to 1 as placeholder.
                    // better to update both dice: player die unchanged (last known) but we can keep it.
                    // we'll fetch current playerDie from DOM? we'll not. but we can store last player roll. for simplicity just show.
                    // we'll call refresh with default die representation (just update computer die).
                    // but we want to keep player die unchanged. we can pass stored value.
                    // we'll store last player roll separately. add state:
                    lastPlayerRoll = 1; // but we don't have it; we'll store last roll values.
                } else {
                    // add to round score
                    roundScore += die;
                    gameMessageDiv.textContent = `ðŸ¤– computer rolled ${die}, round score ${roundScore}`;
                    // computer continues (recursive call with small delay)
                    refreshUI(lastPlayerRoll, die); // need to know player last roll
                    // but we don't track player last roll. we can store it: lastPlayerDie, lastComputerDie.
                }
                // after roll, if not 1, we call computerTurn again (recursive after short delay)
                if (die !== 1 && currentTurn === 'computer' && !gameOver) {
                    setTimeout(computerTurn, 600);
                } else if (die === 1) {
                    // turn passed to player
                    refreshUI(lastPlayerRoll, die);
                    // enable buttons (player turn)
                    setButtonsDisabled(false);
                }
            }

            function holdComputer() {
                // bank computer round score
                computerScore += roundScore;
                roundScore = 0;
                gameMessageDiv.textContent = 'ðŸ¤– computer holds. Your turn.';
                currentTurn = 'player';
                refreshUI(lastPlayerRoll, lastComputerDie); 
                setButtonsDisabled(false);
                // check win condition after hold
                checkGameOver();
            }

            // need to keep last known dice for display
            if (currentTurn === 'computer') {
                setButtonsDisabled(true); // ensure buttons disabled
                // slight delay to feel natural
                setTimeout(computerMove, 400);
            }
        }

        // track last rolled dice (for display)
        let lastPlayerRoll = 1;
        let lastComputerDie = 1;

        // switch to computer turn
        function startComputerTurn() {
            if (gameOver) return;
            currentTurn = 'computer';
            gameMessageDiv.textContent = 'ðŸ’­ Computer thinking...';
            refreshUI(lastPlayerRoll, lastComputerDie);
            setButtonsDisabled(true);
            computerTurn();
        }

        // player roll
        function handlePlayerRoll() {
            if (gameOver || currentTurn !== 'player') return;

            const roll = rollDie();
            lastPlayerRoll = roll;   // store for display
            playerDieDiv.textContent = getDieFace(roll);

            if (roll === 1) {
                // lose round points, switch to computer
                roundScore = 0;
                gameMessageDiv.textContent = 'ðŸ’” You rolled 1! Round lost. Computer turn.';
                refreshUI(roll, lastComputerDie);
                startComputerTurn();
            } else {
                roundScore += roll;
                gameMessageDiv.textContent = `âœ… You rolled ${roll}. round pot: ${roundScore}`;
                refreshUI(roll, lastComputerDie);
                // turn remains player, no change
            }
        }

        // player hold
        function handlePlayerHold() {
            if (gameOver || currentTurn !== 'player') return;
            if (roundScore === 0) {
                gameMessageDiv.textContent = 'âš ï¸ No points to hold. Roll first.';
                return;
            }
            // bank
            playerScore += roundScore;
            roundScore = 0;
            gameMessageDiv.textContent = 'ðŸ’° You held. Computer turn.';
            refreshUI(lastPlayerRoll, lastComputerDie);
            // check win after hold
            if (checkGameOver()) return;
            startComputerTurn();
        }

        // check if either player reached 50 (win condition)
        function checkGameOver() {
            if (playerScore >= 50) {
                gameOver = true;
                gameMessageDiv.textContent = 'ðŸ† YOU WIN! congratulations!';
                turnMessageDiv.textContent = 'ðŸŽ‰ GAME OVER';
                setButtonsDisabled(true);
                return true;
            } else if (computerScore >= 50) {
                gameOver = true;
                gameMessageDiv.textContent = 'ðŸ¤– COMPUTER WINS ... better luck next time.';
                turnMessageDiv.textContent = 'ðŸ GAME OVER';
                setButtonsDisabled(true);
                return true;
            }
            return false;
        }

        // enable/disable action buttons
        function setButtonsDisabled(disabled) {
            rollBtn.disabled = disabled;
            holdBtn.disabled = disabled;
        }

        // reset entire game
        function resetGame() {
            playerScore = 0;
            computerScore = 0;
            roundScore = 0;
            currentTurn = 'player';
            gameOver = false;
            lastPlayerRoll = 1;
            lastComputerDie = 1;
            playerDieDiv.textContent = 'âš€';
            computerDieDiv.textContent = 'âš€';
            gameMessageDiv.textContent = 'New game! Roll the dice.';
            refreshUI(1, 1);
            setButtonsDisabled(false);
        }

        // event listeners
        rollBtn.addEventListener('click', () => {
            handlePlayerRoll();
            checkGameOver();
        });

        holdBtn.addEventListener('click', () => {
            handlePlayerHold();
            // checkGameOver inside hold
        });

        resetBtn.addEventListener('click', () => {
            resetGame();
        });

        // initial reset
        resetGame();

        // helper: for computerTurn we need to hold computer stuff, also need to store lastComputerDie. update during computer rolls
        // override: we'll integrate lastComputerDie set inside computerTurn
        // Let's modify: store computer last die inside computer turn.

        // we'll patch: after computer roll, set lastComputerDie = die. after hold, keep previous. 
        // but we also need to show computer die. we'll store.

        // Re-declare computerTurn with variable access.
        // but already declared above, we need to merge. Instead, rewrite computerTurn with closure access.

        // clean approach: we already have lastComputerDie variable. inside computerTurn we will update.

        // redefining computerTurn with proper updates (since hoisting, we can just reassign later)
        // replace the earlier empty function with full implementation.
        // We'll just replace the whole script section with final version.
        // To avoid confusion, I'll re-start logic:

        // reset state and attach final computer logic using existing variables.
        // use a flag to prevent overlapping turns

        let computerTurnActive = false;

        function startComputerTurn() {
            if (gameOver || currentTurn !== 'computer' || computerTurnActive) return;
            computerTurnActive = true;
            setButtonsDisabled(true);
            gameMessageDiv.textContent = 'ðŸ¤– computer is rolling ...';
            // slight delay then run computer loop
            setTimeout(() => {
                if (gameOver || currentTurn !== 'computer') {
                    computerTurnActive = false;
                    return;
                }
                performComputerDecision();
            }, 400);
        }

        function performComputerDecision() {
            if (gameOver || currentTurn !== 'computer') {
                computerTurnActive = false;
                return;
            }

            // if roundScore >= 8, hold with high probability, or hold if risky
            if (roundScore >= 9) {
                // hold
                computerScore += roundScore;
                roundScore = 0;
                gameMessageDiv.textContent = 'ðŸ¤– computer holds. your turn.';
                currentTurn = 'player';
                refreshUI(lastPlayerRoll, lastComputerDie);
                computerTurnActive = false;
                setButtonsDisabled(false);
                checkGameOver();
                return;
            }

            // otherwise roll
            const roll = rollDie();
            lastComputerDie = roll;
            computerDieDiv.textContent = getDieFace(roll);

            if (roll === 1) {
                // lose round points, switch turn
                roundScore = 0;
                gameMessageDiv.textContent = 'ðŸ’¥ computer rolled 1! your turn.';
                currentTurn = 'player';
                refreshUI(lastPlayerRoll, roll);
                computerTurnActive = false;
                setButtonsDisabled(false);
                // no score add
            } else {
                roundScore += roll;
                gameMessageDiv.textContent = `ðŸ¤– computer rolled ${roll}, round score ${roundScore}`;
                refreshUI(lastPlayerRoll, roll);
                // recursive decision after short delay
                if (currentTurn === 'computer' && !gameOver) {
                    setTimeout(() => performComputerDecision(), 500);
                } else {
                    computerTurnActive = false;
                }
            }
            checkGameOver();
        }

        // Override hold/roll to use new computer turn
        // Reattach:
        rollBtn.onclick = () => {
            if (gameOver || currentTurn !== 'player') return;
            const roll = rollDie();
            lastPlayerRoll = roll;
            playerDieDiv.textContent = getDieFace(roll);
            if (roll === 1) {
                roundScore = 0;
                gameMessageDiv.textContent = 'ðŸ’” You rolled 1! Computer turn.';
                refreshUI(roll, lastComputerDie);
                currentTurn = 'computer';
                startComputerTurn();
            } else {
                roundScore += roll;
                gameMessageDiv.textContent = `âœ… You rolled ${roll}. round pot: ${roundScore}`;
                refreshUI(roll, lastComputerDie);
            }
            checkGameOver();
        };

        holdBtn.onclick = () => {
            if (gameOver || currentTurn !== 'player') return;
            if (roundScore === 0) {
                gameMessageDiv.textContent = 'âš ï¸ Nothing to hold. roll first.';
                return;
            }
            playerScore += roundScore;
            roundScore = 0;
            gameMessageDiv.textContent = 'ðŸ’° You held. Computer turn.';
            refreshUI(lastPlayerRoll, lastComputerDie);
            if (checkGameOver()) return;
            currentTurn = 'computer';
            startComputerTurn();
        };

        resetBtn.onclick = () => {
            playerScore = 0;
            computerScore = 0;
            roundScore = 0;
            currentTurn = 'player';
            gameOver = false;
            lastPlayerRoll = 1;
            lastComputerDie = 1;
            playerDieDiv.textContent = 'âš€';
            computerDieDiv.textContent = 'âš€';
            gameMessageDiv.textContent = 'New game! Roll the dice.';
            refreshUI(1, 1);
            setButtonsDisabled(false);
            computerTurnActive = false;
        };

        // initial display
        refreshUI(1, 1);
        setButtonsDisabled(false);
    })();
</script>
</body>
</html>