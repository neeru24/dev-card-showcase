<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Mandala Creator</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        :root {
            --bg-gradient-1: #0f172a;
            --bg-gradient-2: #1e293b;
            --bg-gradient-3: #0c0a1d;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --accent: #8b5cf6;
            --accent-light: #a78bfa;
            --accent-dark: #7c3aed;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --card-bg: rgba(30, 41, 59, 0.7);
            --border-color: rgba(148, 163, 184, 0.2);
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }
        
        body {
            background: linear-gradient(135deg, var(--bg-gradient-1), var(--bg-gradient-2), var(--bg-gradient-3));
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 30px 0;
            margin-bottom: 20px;
        }
        
        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .logo-icon {
            color: var(--accent);
            font-size: 3rem;
            filter: drop-shadow(0 0 10px rgba(139, 92, 246, 0.5));
        }
        
        h1 {
            font-size: 3.2rem;
            background: linear-gradient(to right, var(--accent), var(--accent-light));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            letter-spacing: 1px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        .tagline {
            color: var(--text-secondary);
            font-size: 1.3rem;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }
        
        @media (max-width: 1100px) {
            .app-container {
                grid-template-columns: 1fr;
            }
            
            .controls-panel {
                order: 2;
            }
            
            .canvas-container {
                order: 1;
            }
        }
        
        .controls-panel {
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            height: fit-content;
        }
        
        .panel-section {
            margin-bottom: 30px;
            padding-bottom: 25px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .panel-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .section-title {
            font-size: 1.4rem;
            margin-bottom: 20px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .section-title i {
            color: var(--accent);
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 1rem;
        }
        
        select, input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.2);
        }
        
        .color-palette {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .color-option {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .color-option:hover {
            transform: scale(1.1);
        }
        
        .color-option.active {
            border-color: white;
            box-shadow: 0 0 10px white;
        }
        
        .tool-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 15px;
        }
        
        .tool-btn {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 15px 10px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }
        
        .tool-btn:hover {
            background: rgba(30, 41, 59, 0.9);
            border-color: var(--accent);
        }
        
        .tool-btn.active {
            background: var(--accent-dark);
            border-color: var(--accent);
            color: white;
        }
        
        .tool-btn i {
            font-size: 1.4rem;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .slider-value {
            min-width: 40px;
            text-align: center;
            color: var(--accent);
            font-weight: 600;
        }
        
        .btn {
            background: linear-gradient(to right, var(--accent), var(--accent-dark));
            color: white;
            border: none;
            padding: 16px 24px;
            font-size: 1.1rem;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
            margin-top: 10px;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(139, 92, 246, 0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: rgba(15, 23, 42, 0.8);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .btn-secondary:hover {
            border-color: var(--accent);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        .canvas-container {
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }
        
        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .canvas-title {
            font-size: 1.6rem;
            color: var(--text-primary);
        }
        
        .canvas-actions {
            display: flex;
            gap: 12px;
        }
        
        .canvas-wrapper {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 15px;
            overflow: hidden;
            border: 1px solid var(--border-color);
            position: relative;
        }
        
        canvas {
            display: block;
            background: #0a0a15;
            border-radius: 10px;
            cursor: crosshair;
        }
        
        .canvas-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.2;
        }
        
        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }
        
        .custom-color-picker {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid var(--border-color);
            cursor: pointer;
        }
        
        #custom-color {
            width: 100%;
            height: 100%;
            border: none;
            cursor: pointer;
        }
        
        .symmetry-visualizer {
            display: flex;
            justify-content: center;
            margin-top: 15px;
        }
        
        .symmetry-dots {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            max-width: 200px;
        }
        
        .symmetry-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--accent);
            opacity: 0.5;
        }
        
        .symmetry-dot.active {
            opacity: 1;
            background-color: var(--accent-light);
            transform: scale(1.2);
        }
        
        .templates-section {
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            margin-bottom: 40px;
        }
        
        .templates-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .template-card {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .template-card:hover {
            transform: translateY(-5px);
            border-color: var(--accent);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        .template-preview {
            width: 120px;
            height: 120px;
            border-radius: 10px;
            background: #0a0a15;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: var(--accent);
        }
        
        .template-name {
            font-weight: 600;
            color: var(--text-primary);
            text-align: center;
        }
        
        footer {
            text-align: center;
            padding: 30px 0;
            color: var(--text-secondary);
            border-top: 1px solid var(--border-color);
            font-size: 0.9rem;
        }
        
        .instructions {
            color: var(--text-secondary);
            margin-top: 20px;
            font-size: 1rem;
            line-height: 1.6;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: var(--card-bg);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            text-align: center;
        }
        
        .modal h3 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: var(--text-primary);
        }
        
        .modal p {
            color: var(--text-secondary);
            margin-bottom: 25px;
            line-height: 1.6;
        }
        
        .modal-buttons {
            display: flex;
            gap: 15px;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
            
            .canvas-actions {
                flex-wrap: wrap;
            }
            
            .tool-buttons {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* Pattern preview in templates */
        .mandala-pattern {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            position: relative;
            transform: rotate(0deg);
            transition: transform 0.5s ease;
        }
        
        .template-card:hover .mandala-pattern {
            transform: rotate(45deg);
        }
        
        .mandala-pattern::before {
            content: '';
            position: absolute;
            top: 10%;
            left: 10%;
            width: 80%;
            height: 80%;
            border-radius: 50%;
            border: 2px solid;
        }
        
        .mandala-pattern::after {
            content: '';
            position: absolute;
            top: 25%;
            left: 25%;
            width: 50%;
            height: 50%;
            border-radius: 50%;
            border: 1px solid;
        }
        
        .mandala-ray {
            position: absolute;
            width: 2px;
            height: 40%;
            background: currentColor;
            top: 0;
            left: 50%;
            transform-origin: bottom center;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <i class="fas fa-snowflake logo-icon"></i>
                <h1>Digital Mandala Creator</h1>
            </div>
            <p class="tagline">Create beautiful, symmetrical mandala art with intuitive drawing tools. Experience the meditative process of digital mandala creation.</p>
        </header>
        
        <div class="app-container">
            <div class="controls-panel">
                <div class="panel-section">
                    <h3 class="section-title"><i class="fas fa-paint-brush"></i> Drawing Tools</h3>
                    
                    <div class="tool-buttons">
                        <div class="tool-btn active" data-tool="brush">
                            <i class="fas fa-paintbrush"></i>
                            <span>Brush</span>
                        </div>
                        <div class="tool-btn" data-tool="line">
                            <i class="fas fa-slash"></i>
                            <span>Line</span>
                        </div>
                        <div class="tool-btn" data-tool="circle">
                            <i class="fas fa-circle"></i>
                            <span>Circle</span>
                        </div>
                        <div class="tool-btn" data-tool="square">
                            <i class="fas fa-square"></i>
                            <span>Square</span>
                        </div>
                        <div class="tool-btn" data-tool="eraser">
                            <i class="fas fa-eraser"></i>
                            <span>Eraser</span>
                        </div>
                        <div class="tool-btn" data-tool="fill">
                            <i class="fas fa-fill-drip"></i>
                            <span>Fill</span>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h3 class="section-title"><i class="fas fa-palette"></i> Colors</h3>
                    
                    <div class="color-palette">
                        <div class="color-option active" style="background-color: #8b5cf6;" data-color="#8b5cf6"></div>
                        <div class="color-option" style="background-color: #10b981;" data-color="#10b981"></div>
                        <div class="color-option" style="background-color: #f59e0b;" data-color="#f59e0b"></div>
                        <div class="color-option" style="background-color: #ef4444;" data-color="#ef4444"></div>
                        <div class="color-option" style="background-color: #3b82f6;" data-color="#3b82f6"></div>
                        <div class="color-option" style="background-color: #ec4899;" data-color="#ec4899"></div>
                        <div class="color-option" style="background-color: #06b6d4;" data-color="#06b6d4"></div>
                        <div class="color-option" style="background-color: #84cc16;" data-color="#84cc16"></div>
                        <div class="color-option" style="background-color: #f97316;" data-color="#f97316"></div>
                        <div class="color-option" style="background-color: #f1f5f9;" data-color="#f1f5f9"></div>
                    </div>
                    
                    <div class="color-picker-container">
                        <label>Custom Color:</label>
                        <div class="custom-color-picker">
                            <input type="color" id="custom-color" value="#8b5cf6">
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h3 class="section-title"><i class="fas fa-expand-alt"></i> Brush Settings</h3>
                    
                    <div class="control-group">
                        <label for="brush-size">Brush Size: <span id="brush-size-value">5</span>px</label>
                        <div class="slider-container">
                            <input type="range" id="brush-size" min="1" max="50" value="5">
                            <div class="slider-value" id="brush-size-display">5</div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label for="brush-opacity">Brush Opacity: <span id="opacity-value">100</span>%</label>
                        <div class="slider-container">
                            <input type="range" id="brush-opacity" min="10" max="100" value="100">
                            <div class="slider-value" id="opacity-display">100%</div>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h3 class="section-title"><i class="fas fa-sync-alt"></i> Symmetry</h3>
                    
                    <div class="control-group">
                        <label for="symmetry-count">Symmetry Sections: <span id="symmetry-value">8</span></label>
                        <div class="slider-container">
                            <input type="range" id="symmetry-count" min="2" max="16" value="8">
                            <div class="slider-value" id="symmetry-display">8</div>
                        </div>
                    </div>
                    
                    <div class="symmetry-visualizer">
                        <div class="symmetry-dots" id="symmetry-dots">
                            <!-- Symmetry dots will be generated here -->
                        </div>
                    </div>
                </div>
                
                <button id="clear-canvas" class="btn btn-secondary">
                    <i class="fas fa-trash-alt"></i> Clear Canvas
                </button>
                
                <button id="save-mandala" class="btn">
                    <i class="fas fa-download"></i> Save Mandala
                </button>
            </div>
            
            <div class="canvas-container">
                <div class="canvas-header">
                    <h2 class="canvas-title">Mandala Canvas</h2>
                    <div class="canvas-actions">
                        <button id="undo-btn" class="btn-secondary" style="padding: 12px 20px;">
                            <i class="fas fa-undo"></i> Undo
                        </button>
                        <button id="redo-btn" class="btn-secondary" style="padding: 12px 20px;">
                            <i class="fas fa-redo"></i> Redo
                        </button>
                        <button id="reset-view" class="btn-secondary" style="padding: 12px 20px;">
                            <i class="fas fa-sync"></i> Reset View
                        </button>
                    </div>
                </div>
                
                <div class="canvas-wrapper">
                    <canvas id="mandala-canvas" width="800" height="800"></canvas>
                    <div class="canvas-grid" id="canvas-grid"></div>
                </div>
                
                <p class="instructions">
                    <i class="fas fa-mouse-pointer"></i> Draw on the canvas to create your mandala. Use symmetry controls to create perfect radial designs.
                </p>
            </div>
        </div>
        
        <section class="templates-section">
            <h3 class="section-title"><i class="fas fa-layer-group"></i> Mandala Templates</h3>
            <p style="color: var(--text-secondary); margin-bottom: 15px;">Click on a template to start with a pre-designed pattern:</p>
            
            <div class="templates-grid">
                <div class="template-card" data-template="basic">
                    <div class="mandala-pattern" style="color: #8b5cf6;">
                        <!-- Rays will be added via JS -->
                    </div>
                    <div class="template-name">Basic Circle</div>
                </div>
                
                <div class="template-card" data-template="floral">
                    <div class="mandala-pattern" style="color: #10b981;">
                        <!-- Rays will be added via JS -->
                    </div>
                    <div class="template-name">Floral Pattern</div>
                </div>
                
                <div class="template-card" data-template="geometric">
                    <div class="mandala-pattern" style="color: #f59e0b;">
                        <!-- Rays will be added via JS -->
                    </div>
                    <div class="template-name">Geometric</div>
                </div>
                
                <div class="template-card" data-template="lotus">
                    <div class="mandala-pattern" style="color: #ec4899;">
                        <!-- Rays will be added via JS -->
                    </div>
                    <div class="template-name">Lotus Design</div>
                </div>
                
                <div class="template-card" data-template="radial">
                    <div class="mandala-pattern" style="color: #3b82f6;">
                        <!-- Rays will be added via JS -->
                    </div>
                    <div class="template-name">Radial Lines</div>
                </div>
                
                <div class="template-card" data-template="star">
                    <div class="mandala-pattern" style="color: #06b6d4;">
                        <!-- Rays will be added via JS -->
                    </div>
                    <div class="template-name">Star Pattern</div>
                </div>
            </div>
        </section>
        
        <footer>
            <p>Digital Mandala Creator Â© 2026 | Create, meditate, and express yourself through symmetrical art</p>
            <p style="margin-top: 10px; font-size: 0.8rem; color: rgba(255,255,255,0.5);">Mandala creation is a meditative practice. Take your time and enjoy the process.</p>
        </footer>
    </div>
    
    <!-- Save Modal -->
    <div class="modal" id="save-modal">
        <div class="modal-content">
            <h3>Save Your Mandala</h3>
            <p>Your mandala has been saved as an image. Right-click on the image below and select "Save image as..." to download it.</p>
            <canvas id="saved-image" width="800" height="800" style="width: 100%; height: auto; border-radius: 10px; margin: 20px 0;"></canvas>
            <div class="modal-buttons">
                <button id="close-modal" class="btn">Close</button>
                <button id="share-mandala" class="btn btn-secondary">Share</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM Elements
            const canvas = document.getElementById('mandala-canvas');
            const ctx = canvas.getContext('2d');
            const savedCanvas = document.getElementById('saved-image');
            const savedCtx = savedCanvas.getContext('2d');
            const brushSizeSlider = document.getElementById('brush-size');
            const brushSizeValue = document.getElementById('brush-size-value');
            const brushSizeDisplay = document.getElementById('brush-size-display');
            const opacitySlider = document.getElementById('brush-opacity');
            const opacityValue = document.getElementById('opacity-value');
            const opacityDisplay = document.getElementById('opacity-display');
            const symmetrySlider = document.getElementById('symmetry-count');
            const symmetryValue = document.getElementById('symmetry-value');
            const symmetryDisplay = document.getElementById('symmetry-display');
            const symmetryDots = document.getElementById('symmetry-dots');
            const colorOptions = document.querySelectorAll('.color-option');
            const customColorPicker = document.getElementById('custom-color');
            const toolButtons = document.querySelectorAll('.tool-btn');
            const clearCanvasBtn = document.getElementById('clear-canvas');
            const saveMandalaBtn = document.getElementById('save-mandala');
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const resetViewBtn = document.getElementById('reset-view');
            const closeModalBtn = document.getElementById('close-modal');
            const shareMandalaBtn = document.getElementById('share-mandala');
            const saveModal = document.getElementById('save-modal');
            const templateCards = document.querySelectorAll('.template-card');
            
            // Drawing state
            let drawing = false;
            let currentTool = 'brush';
            let currentColor = '#8b5cf6';
            let brushSize = 5;
            let opacity = 1.0;
            let symmetry = 8;
            let lastX = 0;
            let lastY = 0;
            let canvasOffsetX = 0;
            let canvasOffsetY = 0;
            let scale = 1;
            
            // History for undo/redo
            let history = [];
            let historyIndex = -1;
            const MAX_HISTORY = 20;
            
            // Initialize canvas
            function initCanvas() {
                // Set canvas size to match container
                const container = canvas.parentElement;
                const size = Math.min(container.clientWidth, container.clientHeight) - 50;
                canvas.width = size;
                canvas.height = size;
                
                // Clear canvas with dark background
                ctx.fillStyle = '#0a0a15';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw center point
                drawCenterPoint();
                
                // Draw symmetry guides
                drawSymmetryGuides();
                
                // Initialize history
                saveToHistory();
                
                // Initialize grid
                drawGrid();
            }
            
            // Draw grid
            function drawGrid() {
                const grid = document.getElementById('canvas-grid');
                grid.innerHTML = '';
                
                const size = canvas.width;
                const cellSize = 50;
                const cols = Math.ceil(size / cellSize);
                const rows = Math.ceil(size / cellSize);
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');
                
                // Draw vertical lines
                for (let i = 0; i <= cols; i++) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', (i * cellSize) + 'px');
                    line.setAttribute('y1', '0');
                    line.setAttribute('x2', (i * cellSize) + 'px');
                    line.setAttribute('y2', '100%');
                    line.setAttribute('stroke', 'rgba(255, 255, 255, 0.1)');
                    line.setAttribute('stroke-width', '1');
                    svg.appendChild(line);
                }
                
                // Draw horizontal lines
                for (let i = 0; i <= rows; i++) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', '0');
                    line.setAttribute('y1', (i * cellSize) + 'px');
                    line.setAttribute('x2', '100%');
                    line.setAttribute('y2', (i * cellSize) + 'px');
                    line.setAttribute('stroke', 'rgba(255, 255, 255, 0.1)');
                    line.setAttribute('stroke-width', '1');
                    svg.appendChild(line);
                }
                
                // Draw center lines
                const centerLineX = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                centerLineX.setAttribute('x1', '50%');
                centerLineX.setAttribute('y1', '0');
                centerLineX.setAttribute('x2', '50%');
                centerLineX.setAttribute('y2', '100%');
                centerLineX.setAttribute('stroke', 'rgba(139, 92, 246, 0.3)');
                centerLineX.setAttribute('stroke-width', '2');
                svg.appendChild(centerLineX);
                
                const centerLineY = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                centerLineY.setAttribute('x1', '0');
                centerLineY.setAttribute('y1', '50%');
                centerLineY.setAttribute('x2', '100%');
                centerLineY.setAttribute('y2', '50%');
                centerLineY.setAttribute('stroke', 'rgba(139, 92, 246, 0.3)');
                centerLineY.setAttribute('stroke-width', '2');
                svg.appendChild(centerLineY);
                
                grid.appendChild(svg);
            }
            
            // Draw center point
            function drawCenterPoint() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(139, 92, 246, 0.8)';
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, 10, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(139, 92, 246, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            // Draw symmetry guides
            function drawSymmetryGuides() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) / 2 - 20;
                
                ctx.strokeStyle = 'rgba(139, 92, 246, 0.2)';
                ctx.lineWidth = 1;
                
                const angleStep = (2 * Math.PI) / symmetry;
                
                for (let i = 0; i < symmetry; i++) {
                    const angle = i * angleStep;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                }
                
                // Draw outer circle
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Update symmetry dots visualizer
            function updateSymmetryDots() {
                symmetryDots.innerHTML = '';
                
                for (let i = 0; i < 16; i++) {
                    const dot = document.createElement('div');
                    dot.className = 'symmetry-dot';
                    if (i < symmetry) {
                        dot.classList.add('active');
                    }
                    symmetryDots.appendChild(dot);
                }
            }
            
            // Initialize template patterns
            function initTemplates() {
                templateCards.forEach(card => {
                    const pattern = card.querySelector('.mandala-pattern');
                    const rays = symmetry; // Use current symmetry value
                    
                    // Clear existing rays
                    pattern.innerHTML = '';
                    
                    // Add rays
                    const angleStep = 360 / rays;
                    for (let i = 0; i < rays; i++) {
                        const ray = document.createElement('div');
                        ray.className = 'mandala-ray';
                        ray.style.transform = `rotate(${i * angleStep}deg)`;
                        pattern.appendChild(ray);
                    }
                });
            }
            
            // Save canvas state to history
            function saveToHistory() {
                // Remove any future states if we're not at the end
                if (historyIndex < history.length - 1) {
                    history = history.slice(0, historyIndex + 1);
                }
                
                // Save current canvas state
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                history.push(imageData);
                historyIndex++;
                
                // Limit history size
                if (history.length > MAX_HISTORY) {
                    history.shift();
                    historyIndex--;
                }
                
                // Update undo/redo button states
                updateUndoRedoButtons();
            }
            
            // Update undo/redo button states
            function updateUndoRedoButtons() {
                undoBtn.disabled = historyIndex <= 0;
                redoBtn.disabled = historyIndex >= history.length - 1;
            }
            
            // Undo last action
            function undo() {
                if (historyIndex > 0) {
                    historyIndex--;
                    const imageData = history[historyIndex];
                    ctx.putImageData(imageData, 0, 0);
                    updateUndoRedoButtons();
                }
            }
            
            // Redo last undone action
            function redo() {
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    const imageData = history[historyIndex];
                    ctx.putImageData(imageData, 0, 0);
                    updateUndoRedoButtons();
                }
            }
            
            // Draw with symmetry
            function drawSymmetrically(x, y, drawFunction) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const angleStep = (2 * Math.PI) / symmetry;
                
                for (let i = 0; i < symmetry; i++) {
                    ctx.save();
                    
                    // Translate to center
                    ctx.translate(centerX, centerY);
                    
                    // Rotate for this section
                    ctx.rotate(i * angleStep);
                    
                    // Translate back and apply drawing
                    ctx.translate(-centerX, -centerY);
                    
                    // Call the drawing function
                    drawFunction(x, y);
                    
                    ctx.restore();
                }
            }
            
            // Start drawing
            function startDrawing(e) {
                drawing = true;
                const rect = canvas.getBoundingClientRect();
                lastX = (e.clientX - rect.left) / scale;
                lastY = (e.clientY - rect.top) / scale;
                
                if (currentTool === 'brush' || currentTool === 'eraser') {
                    draw(e);
                }
            }
            
            // Draw
            function draw(e) {
                if (!drawing) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / scale;
                const y = (e.clientY - rect.top) / scale;
                
                ctx.globalAlpha = opacity;
                
                if (currentTool === 'brush') {
                    ctx.strokeStyle = currentColor;
                    ctx.fillStyle = currentColor;
                    ctx.lineWidth = brushSize;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    drawSymmetrically(x, y, (symX, symY) => {
                        ctx.beginPath();
                        ctx.moveTo(lastX, lastY);
                        ctx.lineTo(symX, symY);
                        ctx.stroke();
                        
                        // Draw dots at the ends for smoother lines
                        ctx.beginPath();
                        ctx.arc(symX, symY, brushSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                    });
                } 
                else if (currentTool === 'eraser') {
                    ctx.strokeStyle = '#0a0a15';
                    ctx.fillStyle = '#0a0a15';
                    ctx.lineWidth = brushSize;
                    ctx.lineCap = 'round';
                    
                    drawSymmetrically(x, y, (symX, symY) => {
                        ctx.beginPath();
                        ctx.moveTo(lastX, lastY);
                        ctx.lineTo(symX, symY);
                        ctx.stroke();
                    });
                }
                else if (currentTool === 'line') {
                    // For line tool, we'll draw on mouse up
                }
                else if (currentTool === 'circle') {
                    // For circle tool, we'll draw on mouse up
                }
                else if (currentTool === 'square') {
                    // For square tool, we'll draw on mouse up
                }
                
                lastX = x;
                lastY = y;
            }
            
            // Stop drawing
            function stopDrawing() {
                if (drawing) {
                    drawing = false;
                    saveToHistory();
                }
            }
            
            // Draw shape on mouse up
            function drawShape(startX, startY, endX, endY) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                ctx.globalAlpha = opacity;
                ctx.strokeStyle = currentColor;
                ctx.fillStyle = currentColor;
                ctx.lineWidth = brushSize;
                
                if (currentTool === 'line') {
                    drawSymmetrically(endX, endY, (symX, symY) => {
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(symX, symY);
                        ctx.stroke();
                    });
                }
                else if (currentTool === 'circle') {
                    const radius = Math.sqrt(
                        Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)
                    );
                    
                    drawSymmetrically(startX, startY, (symX, symY) => {
                        ctx.beginPath();
                        ctx.arc(symX, symY, radius, 0, Math.PI * 2);
                        ctx.stroke();
                    });
                }
                else if (currentTool === 'square') {
                    const size = Math.max(
                        Math.abs(endX - startX),
                        Math.abs(endY - startY)
                    );
                    
                    drawSymmetrically(startX, startY, (symX, symY) => {
                        ctx.beginPath();
                        ctx.rect(symX - size/2, symY - size/2, size, size);
                        ctx.stroke();
                    });
                }
            }
            
            // Fill tool
            function fillArea(x, y) {
                // For simplicity, we'll fill the entire canvas with the current color
                // In a more advanced version, you would implement flood fill algorithm
                ctx.globalAlpha = opacity;
                ctx.fillStyle = currentColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Redraw center and guides
                drawCenterPoint();
                drawSymmetryGuides();
            }
            
            // Clear canvas
            function clearCanvas() {
                if (confirm("Are you sure you want to clear the canvas?")) {
                    ctx.fillStyle = '#0a0a15';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    drawCenterPoint();
                    drawSymmetryGuides();
                    saveToHistory();
                }
            }
            
            // Save mandala as image
            function saveMandala() {
                // Copy canvas to saved canvas
                savedCtx.fillStyle = '#0a0a15';
                savedCtx.fillRect(0, 0, savedCanvas.width, savedCanvas.height);
                savedCtx.drawImage(canvas, 0, 0, savedCanvas.width, savedCanvas.height);
                
                // Show modal
                saveModal.style.display = 'flex';
            }
            
            // Share mandala
            function shareMandala() {
                savedCanvas.toBlob(function(blob) {
                    if (navigator.share && navigator.canShare) {
                        const file = new File([blob], 'mandala.png', { type: 'image/png' });
                        
                        if (navigator.canShare({ files: [file] })) {
                            navigator.share({
                                files: [file],
                                title: 'My Digital Mandala',
                                text: 'Check out this mandala I created with the Digital Mandala Creator!'
                            })
                            .catch(error => console.log('Sharing failed:', error));
                        } else {
                            // Fallback: download
                            const link = document.createElement('a');
                            link.download = 'mandala.png';
                            link.href = savedCanvas.toDataURL('image/png');
                            link.click();
                        }
                    } else {
                        // Fallback: download
                        const link = document.createElement('a');
                        link.download = 'mandala.png';
                        link.href = savedCanvas.toDataURL('image/png');
                        link.click();
                    }
                }, 'image/png');
            }
            
            // Apply template
            function applyTemplate(templateName) {
                // Clear canvas first
                ctx.fillStyle = '#0a0a15';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const maxRadius = Math.min(canvas.width, canvas.height) / 2 - 30;
                
                ctx.strokeStyle = currentColor;
                ctx.fillStyle = currentColor;
                ctx.lineWidth = 3;
                ctx.globalAlpha = 1.0;
                
                switch(templateName) {
                    case 'basic':
                        // Draw concentric circles
                        for (let i = 1; i <= 5; i++) {
                            const radius = (maxRadius / 5) * i;
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'floral':
                        // Draw flower-like pattern
                        const petals = 8;
                        const petalAngle = (2 * Math.PI) / petals;
                        
                        for (let i = 0; i < petals; i++) {
                            ctx.save();
                            ctx.translate(centerX, centerY);
                            ctx.rotate(i * petalAngle);
                            
                            // Draw petal
                            ctx.beginPath();
                            ctx.ellipse(0, maxRadius * 0.6, maxRadius * 0.3, maxRadius * 0.6, 0, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            ctx.restore();
                        }
                        break;
                        
                    case 'geometric':
                        // Draw geometric pattern
                        for (let i = 0; i < symmetry; i++) {
                            ctx.save();
                            ctx.translate(centerX, centerY);
                            ctx.rotate(i * (2 * Math.PI / symmetry));
                            
                            // Draw triangle
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(maxRadius * 0.7, 0);
                            ctx.lineTo(0, maxRadius * 0.4);
                            ctx.closePath();
                            ctx.stroke();
                            
                            ctx.restore();
                        }
                        break;
                        
                    case 'lotus':
                        // Draw lotus pattern
                        const lotusLayers = 3;
                        for (let layer = 0; layer < lotusLayers; layer++) {
                            const layerRadius = maxRadius * (0.3 + layer * 0.2);
                            const layerPetals = 8 + layer * 4;
                            const layerAngle = (2 * Math.PI) / layerPetals;
                            
                            for (let i = 0; i < layerPetals; i++) {
                                ctx.save();
                                ctx.translate(centerX, centerY);
                                ctx.rotate(i * layerAngle);
                                
                                // Draw lotus petal
                                ctx.beginPath();
                                ctx.ellipse(0, layerRadius, layerRadius * 0.4, layerRadius * 0.2, 0, 0, Math.PI * 2);
                                ctx.stroke();
                                
                                ctx.restore();
                            }
                        }
                        break;
                        
                    case 'radial':
                        // Draw radial lines
                        for (let i = 0; i < symmetry; i++) {
                            ctx.save();
                            ctx.translate(centerX, centerY);
                            ctx.rotate(i * (2 * Math.PI / symmetry));
                            
                            // Draw line
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(maxRadius, 0);
                            ctx.stroke();
                            
                            // Draw dots along the line
                            for (let j = 1; j <= 5; j++) {
                                const dotRadius = 5;
                                const dotX = (maxRadius / 6) * j;
                                ctx.beginPath();
                                ctx.arc(dotX, 0, dotRadius, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            
                            ctx.restore();
                        }
                        break;
                        
                    case 'star':
                        // Draw star pattern
                        const starPoints = 8;
                        const starAngle = (2 * Math.PI) / starPoints;
                        
                        for (let i = 0; i < starPoints; i++) {
                            ctx.save();
                            ctx.translate(centerX, centerY);
                            ctx.rotate(i * starAngle);
                            
                            // Draw star point
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(maxRadius * 0.8, 0);
                            ctx.lineTo(maxRadius * 0.4, maxRadius * 0.4);
                            ctx.closePath();
                            ctx.stroke();
                            
                            ctx.restore();
                        }
                        break;
                }
                
                drawCenterPoint();
                saveToHistory();
            }
            
            // Event Listeners
            
            // Brush size slider
            brushSizeSlider.addEventListener('input', function() {
                brushSize = parseInt(this.value);
                brushSizeValue.textContent = brushSize;
                brushSizeDisplay.textContent = brushSize;
            });
            
            // Opacity slider
            opacitySlider.addEventListener('input', function() {
                opacity = parseInt(this.value) / 100;
                opacityValue.textContent = this.value;
                opacityDisplay.textContent = this.value + '%';
            });
            
            // Symmetry slider
            symmetrySlider.addEventListener('input', function() {
                symmetry = parseInt(this.value);
                symmetryValue.textContent = symmetry;
                symmetryDisplay.textContent = symmetry;
                
                // Update symmetry guides
                ctx.fillStyle = '#0a0a15';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                drawCenterPoint();
                drawSymmetryGuides();
                
                // Update symmetry dots
                updateSymmetryDots();
                
                // Update template patterns
                initTemplates();
            });
            
            // Color options
            colorOptions.forEach(option => {
                option.addEventListener('click', function() {
                    colorOptions.forEach(opt => opt.classList.remove('active'));
                    this.classList.add('active');
                    currentColor = this.getAttribute('data-color');
                    customColorPicker.value = currentColor;
                });
            });
            
            // Custom color picker
            customColorPicker.addEventListener('input', function() {
                currentColor = this.value;
                
                // Find and activate matching color option, or deactivate all
                let foundMatch = false;
                colorOptions.forEach(option => {
                    if (option.getAttribute('data-color') === currentColor) {
                        option.classList.add('active');
                        foundMatch = true;
                    } else {
                        option.classList.remove('active');
                    }
                });
                
                // If no match found, deactivate all color options
                if (!foundMatch) {
                    colorOptions.forEach(option => option.classList.remove('active'));
                }
            });
            
            // Tool buttons
            toolButtons.forEach(button => {
                button.addEventListener('click', function() {
                    toolButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    currentTool = this.getAttribute('data-tool');
                });
            });
            
            // Canvas events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            // Touch events for mobile
            canvas.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                startDrawing(touch);
            });
            
            canvas.addEventListener('touchmove', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                draw(touch);
            });
            
            canvas.addEventListener('touchend', stopDrawing);
            
            // Clear canvas button
            clearCanvasBtn.addEventListener('click', clearCanvas);
            
            // Save mandala button
            saveMandalaBtn.addEventListener('click', saveMandala);
            
            // Undo/redo buttons
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            
            // Reset view button
            resetViewBtn.addEventListener('click', function() {
                // Reset any view transformations (zoom/pan) if implemented
                // For now, just reinitialize canvas
                initCanvas();
            });
            
            // Close modal button
            closeModalBtn.addEventListener('click', function() {
                saveModal.style.display = 'none';
            });
            
            // Share mandala button
            shareMandalaBtn.addEventListener('click', shareMandala);
            
            // Template cards
            templateCards.forEach(card => {
                card.addEventListener('click', function() {
                    const templateName = this.getAttribute('data-template');
                    
                    // Update color based on template
                    const patternColor = this.querySelector('.mandala-pattern').style.color;
                    currentColor = patternColor;
                    customColorPicker.value = patternColor;
                    
                    // Update color options
                    colorOptions.forEach(option => {
                        if (option.getAttribute('data-color') === patternColor) {
                            option.classList.add('active');
                        } else {
                            option.classList.remove('active');
                        }
                    });
                    
                    applyTemplate(templateName);
                });
            });
            
            // Initialize everything
            initCanvas();
            updateSymmetryDots();
            initTemplates();
            updateUndoRedoButtons();
            
            // Handle window resize
            window.addEventListener('resize', function() {
                initCanvas();
                drawGrid();
            });
        });
    </script>
</body>
</html>