<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé¥ Memory Match ¬∑ Find the Pairs</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
        }
        body {
            background: linear-gradient(145deg, #5d3a6b, #3a2a47);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .game-wrapper {
            background: #6d4c7d;
            padding: 2rem;
            border-radius: 4rem;
            box-shadow: 0 30px 30px -10px black, inset 0 -3px 0 #3d2a47, inset 0 3px 15px #b38fd9;
            border: 3px solid #b38fd9;
        }
        h1 {
            text-align: center;
            font-size: 3.5rem;
            font-weight: 800;
            color: #ffd966;
            text-shadow: 0 5px 0 #b38f40, 0 10px 15px black;
            letter-spacing: 4px;
            margin-bottom: 0.2rem;
        }
        .sub {
            text-align: center;
            color: #e6d9ff;
            font-size: 1.2rem;
            margin-bottom: 1.5rem;
        }
        .game-container {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            justify-content: center;
        }
        .canvas-area {
            background: #4f3661;
            padding: 1.5rem;
            border-radius: 3rem;
            box-shadow: inset 0 0 0 3px #2e1f38, 0 15px 20px black;
        }
        canvas {
            display: block;
            width: 600px;
            height: 600px;
            border-radius: 2rem;
            background: #2e1f38;
            box-shadow: 0 0 0 2px #b38fd9;
            cursor: pointer;
        }
        .info-panel {
            background: #4f3661;
            padding: 2rem 1.8rem;
            border-radius: 3rem;
            min-width: 280px;
            box-shadow: inset 0 -3px 0 #2e1f38, 0 15px 20px black;
            border: 2px solid #b38fd9;
        }
        .stats-card {
            background: #2e1f38;
            border-radius: 2rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 2px solid #b38fd9;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 1rem 0;
            color: #e6d9ff;
            font-size: 1.2rem;
        }
        .stat-value {
            font-size: 2rem;
            font-weight: 800;
            color: #ffd966;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #1a1220;
            border-radius: 1rem;
            margin: 1rem 0;
            overflow: hidden;
            border: 2px solid #8f6bb3;
        }
        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ffd966, #ffaa44);
            transition: width 0.3s;
        }
        .move-counter {
            background: #2e1f38;
            border-radius: 2rem;
            padding: 1.5rem;
            text-align: center;
            margin-bottom: 1.5rem;
            border: 2px solid #ffd966;
        }
        .moves-value {
            font-size: 3.5rem;
            color: #ffd966;
            font-weight: 800;
            line-height: 1;
        }
        .moves-label {
            color: #e6d9ff;
            font-size: 1rem;
        }
        .best-score {
            background: #2e1f38;
            border-radius: 2rem;
            padding: 1rem;
            text-align: center;
            margin: 1.5rem 0;
            border: 2px solid #b38fd9;
            color: #e6d9ff;
        }
        .best-score span {
            color: #ffd966;
            font-size: 1.5rem;
            font-weight: 700;
            margin-left: 0.5rem;
        }
        .controls {
            display: flex;
            gap: 0.8rem;
            margin-top: 1rem;
        }
        button {
            background: #8f6bb3;
            border: none;
            color: white;
            font-size: 1.2rem;
            font-weight: 700;
            padding: 0.8rem 1.2rem;
            border-radius: 2rem;
            box-shadow: 0 5px 0 #5a3f77;
            cursor: pointer;
            transition: 0.07s;
            border: 1px solid #c7a9ff;
            flex: 1;
        }
        button:active {
            transform: translateY(3px);
            box-shadow: 0 2px 0 #5a3f77;
        }
        .difficulty {
            display: flex;
            gap: 0.5rem;
            margin: 1.5rem 0;
        }
        .difficulty-btn {
            background: #2e1f38;
            color: #e6d9ff;
            border: 2px solid #8f6bb3;
            padding: 0.5rem;
            border-radius: 2rem;
            cursor: pointer;
            font-weight: 600;
            text-align: center;
            flex: 1;
            font-size: 0.9rem;
        }
        .difficulty-btn.selected {
            background: #ffd966;
            color: #2e1f38;
            border-color: #ffaa44;
        }
        .message-box {
            background: #2e1f38;
            border-radius: 2rem;
            padding: 1rem;
            text-align: center;
            color: #ffd966;
            font-weight: 600;
            min-height: 4rem;
            margin: 1rem 0;
            border: 2px solid #b38fd9;
        }
        .footer {
            margin-top: 1.5rem;
            text-align: center;
            color: #c7a9ff;
        }
    </style>
</head>
<body>
<div class="game-wrapper">
    <h1>üé¥ MEMORY MATCH</h1>
    <div class="sub">flip cards ¬∑ find matching pairs</div>

    <div class="game-container">
        <div class="canvas-area">
            <canvas id="gameCanvas" width="600" height="600"></canvas>
        </div>

        <div class="info-panel">
            <div class="stats-card">
                <div class="stat-row">
                    <span>PAIRS LEFT</span>
                    <span class="stat-value" id="pairsLeft">8</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
                <div class="stat-row">
                    <span>MATCHED</span>
                    <span class="stat-value" id="matchedCount">0/8</span>
                </div>
            </div>

            <div class="move-counter">
                <div class="moves-value" id="movesDisplay">0</div>
                <div class="moves-label">TOTAL MOVES</div>
            </div>

            <div class="best-score">
                üèÜ BEST
                <span id="bestScore">0</span> MOVES
            </div>

            <div class="difficulty">
                <div class="difficulty-btn selected" data-diff="easy">4x4</div>
                <div class="difficulty-btn" data-diff="medium">4x6</div>
                <div class="difficulty-btn" data-diff="hard">6x6</div>
            </div>

            <div class="message-box" id="messageDisplay">
                Click any card to start
            </div>

            <div class="controls">
                <button id="newGameBtn">üîÑ NEW GAME</button>
                <button id="resetBtn">‚ü≤ RESET</button>
            </div>
        </div>
    </div>
    <div class="footer">
        ‚ú® find all matching pairs ¬∑ remember the positions!
    </div>
</div>

<script>
    (function() {
        // ---------- MEMORY MATCH GAME ----------
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const pairsLeft = document.getElementById('pairsLeft');
        const progressFill = document.getElementById('progressFill');
        const matchedCount = document.getElementById('matchedCount');
        const movesDisplay = document.getElementById('movesDisplay');
        const bestScore = document.getElementById('bestScore');
        const messageDisplay = document.getElementById('messageDisplay');
        const newGameBtn = document.getElementById('newGameBtn');
        const resetBtn = document.getElementById('resetBtn');
        const difficultyBtns = document.querySelectorAll('.difficulty-btn');

        // Game constants
        const CARD_COLORS = [
            '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4',
            '#ffeaa7', '#dfe6e9', '#fdcb6e', '#e17055',
            '#6c5ce7', '#00b894', '#fd79a8', '#74b9ff',
            '#f9ca24', '#f0932b', '#badc58', '#22a6b3'
        ];

        // Game state
        let grid = [];
        let rows = 4;
        let cols = 4;
        let cardSize = 140; // 600/4 ‚âà 150, minus padding
        let cardPadding = 10;
        
        let cards = [];
        let flippedCards = [];
        let matchedPairs = 0;
        let totalPairs = 0;
        let moves = 0;
        let canFlip = true;
        let gameComplete = false;
        
        // Best score storage
        let bestScores = {
            easy: localStorage.getItem('memoryBestEasy') || Infinity,
            medium: localStorage.getItem('memoryBestMedium') || Infinity,
            hard: localStorage.getItem('memoryBestHard') || Infinity
        };

        // Update best score display
        function updateBestScore() {
            const diff = getCurrentDifficulty();
            const score = bestScores[diff];
            bestScore.textContent = score === Infinity ? '‚Äî' : score;
        }

        // Get current difficulty
        function getCurrentDifficulty() {
            if (rows === 4 && cols === 4) return 'easy';
            if (rows === 4 && cols === 6) return 'medium';
            return 'hard';
        }

        // Initialize game
        function initGame() {
            // Calculate card size based on grid
            cardSize = (canvas.width / Math.max(rows, cols)) - cardPadding;
            
            // Create pairs
            totalPairs = (rows * cols) / 2;
            let values = [];
            
            // Generate pairs
            for (let i = 0; i < totalPairs; i++) {
                values.push(i, i); // Two of each
            }
            
            // Shuffle
            for (let i = values.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [values[i], values[j]] = [values[j], values[i]];
            }
            
            // Create cards
            cards = [];
            let index = 0;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    cards.push({
                        row,
                        col,
                        value: values[index],
                        flipped: false,
                        matched: false,
                        color: CARD_COLORS[values[index] % CARD_COLORS.length]
                    });
                    index++;
                }
            }
            
            // Reset game state
            flippedCards = [];
            matchedPairs = 0;
            moves = 0;
            canFlip = true;
            gameComplete = false;
            
            // Update UI
            updateStats();
            updateBestScore();
            messageDisplay.textContent = 'Find matching pairs!';
            
            // Draw
            draw();
        }

        // Update statistics
        function updateStats() {
            const remaining = totalPairs - matchedPairs;
            pairsLeft.textContent = remaining;
            matchedCount.textContent = `${matchedPairs}/${totalPairs}`;
            
            const progress = (matchedPairs / totalPairs) * 100;
            progressFill.style.width = progress + '%';
            
            movesDisplay.textContent = moves;
        }

        // Check if game is complete
        function checkGameComplete() {
            if (matchedPairs === totalPairs) {
                gameComplete = true;
                messageDisplay.textContent = 'üéâ CONGRATULATIONS! You won!';
                
                // Update best score
                const diff = getCurrentDifficulty();
                if (moves < bestScores[diff]) {
                    bestScores[diff] = moves;
                    localStorage.setItem(`memoryBest${diff.charAt(0).toUpperCase() + diff.slice(1)}`, moves);
                    updateBestScore();
                    messageDisplay.textContent = 'üéâ NEW RECORD! Congratulations!';
                }
            }
        }

        // Handle card click
        function handleCardClick(row, col) {
            if (!canFlip || gameComplete) return;
            
            // Find card
            const cardIndex = cards.findIndex(c => c.row === row && c.col === col);
            const card = cards[cardIndex];
            
            // Check if card can be flipped
            if (card.flipped || card.matched) return;
            if (flippedCards.length === 2) return;
            
            // Flip card
            card.flipped = true;
            flippedCards.push(card);
            
            // Check for match if we have 2 cards
            if (flippedCards.length === 2) {
                moves++;
                canFlip = false;
                
                const [card1, card2] = flippedCards;
                
                if (card1.value === card2.value) {
                    // Match found
                    setTimeout(() => {
                        card1.matched = true;
                        card2.matched = true;
                        matchedPairs++;
                        
                        flippedCards = [];
                        canFlip = true;
                        
                        updateStats();
                        checkGameComplete();
                        draw();
                        
                        messageDisplay.textContent = '‚úÖ Match found!';
                    }, 500);
                } else {
                    // No match
                    setTimeout(() => {
                        card1.flipped = false;
                        card2.flipped = false;
                        flippedCards = [];
                        canFlip = true;
                        
                        draw();
                        
                        messageDisplay.textContent = '‚ùå Not a match, try again';
                    }, 800);
                }
            }
            
            updateStats();
            draw();
        }

        // Draw the game
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw cards
            cards.forEach(card => {
                const x = card.col * (cardSize + cardPadding) + cardPadding;
                const y = card.row * (cardSize + cardPadding) + cardPadding;
                
                // Card shadow
                ctx.shadowColor = '#00000080';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetY = 4;
                
                if (card.matched) {
                    // Matched card (glowing effect)
                    ctx.shadowColor = '#ffd966';
                    ctx.shadowBlur = 20;
                    
                    ctx.fillStyle = card.color;
                    ctx.beginPath();
                    ctx.roundRect(x, y, cardSize, cardSize, 15);
                    ctx.fill();
                    
                    // Checkmark
                    ctx.shadowBlur = 0;
                    ctx.font = `bold ${cardSize * 0.6}px 'Segoe UI'`;
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('‚úì', x + cardSize/2, y + cardSize/2);
                    
                } else if (card.flipped) {
                    // Flipped card (showing color)
                    ctx.fillStyle = card.color;
                    ctx.beginPath();
                    ctx.roundRect(x, y, cardSize, cardSize, 15);
                    ctx.fill();
                    
                    // Pattern
                    ctx.fillStyle = '#ffffff60';
                    ctx.font = `bold ${cardSize * 0.4}px 'Segoe UI'`;
                    ctx.fillText('?', x + cardSize/2, y + cardSize/2);
                    
                } else {
                    // Face down card
                    // Gradient background
                    const gradient = ctx.createLinearGradient(x, y, x + cardSize, y + cardSize);
                    gradient.addColorStop(0, '#8f6bb3');
                    gradient.addColorStop(1, '#6d4c7d');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.roundRect(x, y, cardSize, cardSize, 15);
                    ctx.fill();
                    
                    // Pattern
                    ctx.strokeStyle = '#e6d9ff40';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(x + 10, y + 10 + i * 20);
                        ctx.lineTo(x + cardSize - 10, y + 10 + i * 20);
                        ctx.stroke();
                    }
                }
                
                // Card border
                ctx.shadowBlur = 0;
                ctx.strokeStyle = '#e6d9ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(x, y, cardSize, cardSize, 15);
                ctx.stroke();
            });

            // Game complete overlay
            if (gameComplete) {
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#000000b0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#ffd966';
                ctx.font = 'bold 40px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('YOU WIN!', canvas.width/2, canvas.height/2 - 30);
                
                ctx.font = '24px Segoe UI';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(`Moves: ${moves}`, canvas.width/2, canvas.height/2 + 20);
            }
        }

        // Helper for rounded rect
        CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.quadraticCurveTo(x + w, y, x + w, y + r);
            this.lineTo(x + w, y + h - r);
            this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            this.lineTo(x + r, y + h);
            this.quadraticCurveTo(x, y + h, x, y + h - r);
            this.lineTo(x, y + r);
            this.quadraticCurveTo(x, y, x + r, y);
            return this;
        };

        // Event listeners
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            // Calculate which card was clicked
            const col = Math.floor(x / (cardSize + cardPadding));
            const row = Math.floor(y / (cardSize + cardPadding));
            
            if (row >= 0 && row < rows && col >= 0 && col < cols) {
                handleCardClick(row, col);
            }
        });

        newGameBtn.addEventListener('click', () => {
            initGame();
        });

        resetBtn.addEventListener('click', () => {
            // Reset current game
            cards.forEach(card => {
                card.flipped = false;
                card.matched = false;
            });
            flippedCards = [];
            matchedPairs = 0;
            moves = 0;
            canFlip = true;
            gameComplete = false;
            
            updateStats();
            messageDisplay.textContent = 'Game reset';
            draw();
        });

        difficultyBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                difficultyBtns.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                
                const diff = btn.dataset.diff;
                switch(diff) {
                    case 'easy':
                        rows = 4;
                        cols = 4;
                        break;
                    case 'medium':
                        rows = 4;
                        cols = 6;
                        break;
                    case 'hard':
                        rows = 6;
                        cols = 6;
                        break;
                }
                
                initGame();
            });
        });

        // Initialize game
        initGame();
    })();
</script>
</body>
</html>